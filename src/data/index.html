<!DOCTYPE html>
<html>
<head>
    <title>WebSocket Test</title>
    <style>
		.title {
			text-align: center;
			border: 1px solid rgba(255, 255, 255, 0.2);
			border-radius: 20px;
			padding: 20px 40px;
			text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
			letter-spacing: 1px;
			margin: 0;
		}
		.yscale-controls {
			margin: 5px 0;
			padding: 5px;
			background: #e8f4fd;
			border: 1px solid #0ea5e9;
			border-radius: 4px;
		}
		.yscale-info {
			font-size: 12px;
			color: #0369a1;
			font-weight: bold;
		}
        .limit-indicator {
            color: red;
            font-weight: bold;
            visibility: hidden;
        }
        .limit-indicator.active {
            visibility: visible;
        }
        #scrollLeft:disabled, #scrollRight:disabled {
            cursor: not-allowed;
        }
        .scope-controls {
            margin: 5px 0;
            padding: 5px;
            background: #f5f5f5;
            border: 1px solid #ddd;
        }
        .timebase-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 5px 0;
        }
        .control-panel {
            margin: 20px;
            padding: 10px;
            border: 1px solid #ccc;
        }
         /* NUOVO: Container flexbox per elementi affiancati */
        .flex-container {
            display: flex;
            gap: 20px; /* Spazio tra gli elementi */
            margin: 10px 0;
        }
        
        /* NUOVO: Stili per i singoli elementi flex */
        .flex-item {
            flex: 1; /* Ogni elemento occupa lo stesso spazio */
            padding: 10px;
            background-color: #e0e0e0;
            border-radius: 5px;
        }
        
        /* Responsive: su schermi piccoli, torna in colonna */
        @media (max-width: 768px) {
            .flex-container {
                flex-direction: column;
            }
        }
        #log {
            margin-top: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            height: 200px;
            overflow-y: auto;
        }
        .stats {
            margin: 10px 0;
            padding: 10px;
            background-color: #e0e0e0;
        }
        .plot-container {
            position: relative;
            margin: 10px 0;
        }
        #plotCanvas {
            width: 100%;
            height: 400px;  /* ridotto da 600px a 400px per comprimere verticalmente */
            border: 1px solid #ccc;
        }
        .plot-controls {
            margin: 5px 0;
            padding: 5px;
            background: #f5f5f5;
            border: 1px solid #ddd;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .buffer-controls {
            margin: 5px 0;
            padding: 5px;
            background: #f5f5f5;
            border: 1px solid #ddd;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .zoom-box {
            position: absolute;
            border: 1px dashed blue;
            background: rgba(0, 0, 255, 0.1);
            pointer-events: none;
            display: none;
        }
        .value-info {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            padding: 5px;
            display: none;
            pointer-events: none;
        }
        #fileInput {
            display: none;
        }
        .test-signal-controls {
            margin: 5px 0;
            padding: 5px;
            background: #f5f5f5;
            border: 1px solid #ddd;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .green {
            background-color: #22c55e;
        }

        .red {
            background-color: #ef4444;
        }
        .overflow-box {
            #width: 150px;
            padding: 5px;
            text-align: center;
            border-radius: 8px;
            font-weight: bold;
            color: white;
            transition: background-color 0.3s;
            mask-origin: 5px;
        }
    </style>
</head>
<body>
    <h1 class="title">Websocket data analysis</h1>

    <div class="control-panel">
        <div class="config-item">
            <label for="sampleRate">Sample Rate:</label>
            <select id="sampleRate" onchange="updateConfig('samplerate', this.value)">
                <option value="200">200 sps</option>
                <option value="600">600 sps</option>
                <option value="1000">1000 sps</option>
				<option value="2000">2000 sps</option>
				<option value="3000">3000 sps</option>
				<option value="6000">6000 sps</option>
                <option value="10000">10 Ksps</option>
                <option value="15000">15 Ksps</option>
                <option value="30000" selected>30 kHz</option>
            </select>
        </div>

        <div class="config-item">
            <label for="emaAlpha">EMA Alpha:</label>
            <select id="emaAlpha" onchange="updateConfig('alfaema', this.value)">
                <option value="0.05">0.05</option>
                <option value="0.1" selected>0.10</option>
                <option value="0.2">0.20</option>
                <option value="0.3">0.30</option>
                <option value="0.5">0.50</option>
            </select>
        </div>
        <div class="buffer-controls">
            <label>Buffer Duration (s):
                <input type="number" id="bufferDuration" value="10" min="1" max="3600" 
                       onchange="updateBufferSize()">
            </label>
            <span>Buffer Size: <span id="bufferInfo">0/0</span></span>
        </div>       
        <div class="config-item">
            <label>Streaming Control:</label>
            <button id="streamToggle" onclick="toggleStreaming()">Start Streaming</button>
        </div>

        <!-- MODIFICATO: Wrapper flexbox per Current Configuration e Batch Stats -->
        <div class="flex-container">
            <div class="flex-item">
                <label><strong>Current Configuration:</strong></label>
                <div id="currentConfig">Waiting for connection...</div>
            </div>
            
            <div class="flex-item">
                <label><strong>Batch Stats:</strong></label>
                <div id="batchStats">No data yet</div>
            </div>
			 <div id="overflowBox" class="overflow-box green flex-item">
                OVERFLOW
            </div>
        </div>
        <div class="test-signal-controls">
            <label>Input selection:</label>
            <label>
                <input type="radio" id="enableADCSignal" name="testSignal">
                ADC real input
            </label>
            <label>
                <input type="radio" id="enableTestSignal0" name="testSignal">
                Local emulated sine wave
            </label>
            <label>
                <input type="radio" id="enableTestSignal1" name="testSignal">
                Local emulated jump
            </label>
            <label>
                <input type="radio" id="enableADCToneL" name="testSignal">
                ADC real tone Low
            </label>
            <label>
                <input type="radio" id="enableADCToneH" name="testSignal">
                ADC real tone High
            </label>
            <label>Sine wave params:</label>
            <label>Frequency (Hz):
                <input type="number" id="testFrequency" value="1" min="1" max="100" step="1" 
                       onchange="updateConfig('freq', this.value)">
            </label>
            <label>Base Amplitude:
                <input type="number" id="testAmplitude" value="4194304" min="1000" max="8388608">
            </label>
            <span id="testSignalInfo">Samples per batch: 0</span>
        </div>
        <!-- CORRETTO: -->
		<div class="filter-controls">
			<label>Recorded data filtering:</label>
			<label>
				<input type="radio" name="filter" value="none" checked>
				None
			</label>
			<label>
				<input type="radio" name="filter" value="kalman">
				Kalman
			</label>
		</div>
        <div class="scope-controls">
            <div class="timebase-controls">
                <label>Timebase (ms/div):
                    <select id="timebaseDiv" onchange="updateTimebase()">
                        <option value="0.005">0.005</option>
                        <option value="0.01">0.01</option>
                        <option value="0.02">0.02</option>
                        <option value="0.05">0.05</option>
                        <option value="0.1">0.1</option>
                        <option value="0.2">0.2</option>
                        <option value="0.5">0.5</option>
                        <option value="1" selected>1</option>
                        <option value="2">2</option>
                        <option value="5">5</option>
                        <option value="10">10</option>
                        <option value="20">20</option>
                        <option value="50">50</option>
                    </select>
                </label>
                <button id="recordBtn" onclick="toggleRecording()">Start Recording</button>
                <button id="loadRecordBtn" onclick="document.getElementById('recordFileInput').click()">Load Record</button>
                <button id="play">></button>
                <button id="scrollLeft"><<</button>
                <button id="scrollRight">>></button>
                <button id="scrollLeftFast"><<<</button>
                <button id="scrollRightFast">>>></button>
				<button onclick="centerViewOnData()">Center on Data</button>
                <label>File Name Prefix:
                    <input type="text" id="filePrefix" value="data">
                </label>
				<input type="file" id="recordFileInput" accept=".txt,.json" style="display: none">

            </div>
            </div>
        </div>
    </div>

    <div class="plot-container">
        <div class="plot-controls">
            <button onclick="resetView()">Reset View</button>
        </div>
        <canvas id="plotCanvas"></canvas>
        <div class="zoom-box" id="zoomBox"></div>
        <div class="value-info" id="valueInfo"></div>
    </div>

    <div id="log"></div>

    <script src="matrixUtils.js"></script>
    <script src="filter.js"></script>       

    <script>
		var counter = 0;
        // Base configuration variables
        let SAMPLE_RATE = 30000;
        const EXPECTED_BATCH_RATE = 200;
        let wsData, wsControl;
        let isStreaming = false;
        let isPaused = false;
        let batchCount = 0;
        let lastBatchTime = null;
        let batchIntervals = [];
        let batchBuffer = [];
        // Test signal variables
        let testSignalTime = 0;
        let lastTestSignalUpdate = 0;
        let thresholds = null;
        let testSignalEnabled0 = false;
        let testSignalEnabled1 = false;
        let remoteTestEnabled = false;
        let adcSignalEnabled = false;
        let remoteTestTone = false;
        let inputMode = true;
        
        const MAX_INTERVALS = 200;
        let bufferDurationSec = 10;
        let bufferTimespan = bufferDurationSec * 1000000; // converti in microsecondi
        let maxBufferSize = Math.ceil((bufferDurationSec * 1000) / 5);
        let currBatchIndex = 0;
        let lastFrameTime = 0;
        let filterh = new Filter();
        let filtera = new Filter();

        // Variabili per registrazione
        let isRecording = false;
        let recordBuffer = [];
        let recordBufferSize = 50000; // Circa 250 secondi di dati con intervallo 5ms
        let currPlayIndex = 0;

        // Display configuration
        const MIN_PLOT_INTERVAL = 5;
        const MIN_PIXEL_DELTA = 2;
        const padding = 10;
        const TARGET_POINTS = 3000;

        // Oscilloscope specific variables
        // Variabili di stato per la vista
        let xScale = { min: 0, max: 100 };
        let yScale = { min: 0, max: 8388608 };
        let timebaseDiv = 5;      // ms per divisione
        const DIVISIONS_X = 10;   // divisioni orizzontali
        let viewOffset = 0;       // offset temporale per lo scroll
        let pausedAt = null;      // timestamp quando messo in pausa
        let animationFrameId = null;  // ID per cancelAnimationFrame
        let isAtLeftLimit = false;  // flag per limite sinistro

        // Variabili di stato per zoom e pan
        //let isMouseDown = false;
        let startX = 0;
        let startY = 0;
        let timers = [];
		let autoScale = true; // Flag per abilitare/disabilitare auto-scaling
		let yScaleBuffer = []; // Buffer per valori recenti
		const Y_SCALE_BUFFER_SIZE = 500; // Numero di campioni da considerare per la scala
        // scroll management
        const delay = (msec) => new Promise(resolve => setTimeout(resolve, msec)) ;
        let isScrolling = false;
        let right = true;
        const leftButton = document.getElementById('scrollLeft');
        const rightButton = document.getElementById('scrollRight');
        const leftButtonFast = document.getElementById('scrollLeftFast');
        const rightButtonFast = document.getElementById('scrollRightFast');
        // Setup canvas
        const canvas = document.getElementById('plotCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        window.addEventListener('resize', resizeCanvas);
		window.addEventListener('load', () => {
			addMetadataControls();
			addEMAControlsForJumpPhases();
			updateSamplesPerBatch();
			addYScaleControls();
			setInterval(updateYScaleInfo, 1000);
			addSaveLoadControls(); // Aggiungi i nuovi controlli
			console.log('🎛️ Sistema EMA completo con pulsante ricalcola inizializzato');
		});
		// Variabile globale per il gain       

        leftButton.onmousedown = async () => {
            isScrolling = true;
            while (isScrolling) {
                scrollView(-timebaseDiv * 10000);
                await delay(200);
            }
        }
        rightButton.onmousedown = async () => {
            isScrolling = true;
            while (isScrolling) {
                scrollView(timebaseDiv * 10000);
                await delay(200);
            }
        }
        leftButtonFast.onmousedown = async () => {
            isScrolling = true;
            while (isScrolling) {
                scrollView(-timebaseDiv * 100000);
                await delay(200);
            }
        }
        rightButtonFast.onmousedown = async () => {
            isScrolling = true;
            while (isScrolling) {
                scrollView(timebaseDiv * 100000);
                await delay(200);
            }
        }
        leftButton.onmouseup = () => {
            isScrolling = false;
        }
        rightButton.onmouseup = () => {
            isScrolling = false;
        }
        leftButtonFast.onmouseup = () => {
            isScrolling = false;
        }
        rightButtonFast.onmouseup = () => {
            isScrolling = false;
        }
        
        const radioButtons = document.querySelectorAll('input[name="filter"]');
        radioButtons.forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (e.target.checked) {
                    console.log('Selected:', e.target.value);
                    if(e.target.value =="kalman"){
                        filterh = new JumpHeightKalmanFilter(1/SAMPLE_RATE);
                        filtera = new AccelerationKalmanFilter(1/SAMPLE_RATE);
                    }else{
                        filterh = new Filter();
                        filtera = new Filter();
                    }
                }
            });
        });

        // Seleziona tutti i radio button con lo stesso nome
        const radioButtons2 = document.querySelectorAll('input[name="testSignal"]');
        // Funzione per gestire checked/unchecked

        function handleRadioChange(send = true) {
            const radio1 = document.getElementById('enableADCSignal');
            const radio2 = document.getElementById('enableTestSignal0');
            const radio3 = document.getElementById('enableTestSignal1');
            const radio4 = document.getElementById('enableADCToneL');
            const radio5 = document.getElementById('enableADCToneH');

            if (radio1.checked) {
                console.log('Opzione adc input selezionata');
                inputMode = true;
                adcSignalEnabled = true;
                testSignalTime = 0;
                resetView();
                updateSamplesPerBatch();
                const batch = {
                    t: 0,
                    v: [0]
                };
                onmessageEvent({ data: JSON.stringify(batch) });
                if(send) updateConfig("mode", 0);
            } else {
                adcSignalEnabled = false;
                console.log('Opzione adc input deselezionata');
            }

            if (radio2.checked) {
                console.log('Opzione sine input selezionata');
                inputMode = true;
                testSignalEnabled0 = true;
                testSignalTime = 0;
                resetView();
                updateSamplesPerBatch();
                generateTestSignal0();
            } else {
                testSignalEnabled0 = false;
                console.log('Opzione sine input deselezionata');
            }

            if (radio3.checked) {
                console.log('Opzione simulated jump selezionata');                   
                inputMode = true;
                testSignalEnabled1 = true;
                testSignalTime = 0;
                resetView();
                updateSamplesPerBatch();
                generateTestSignal1();   
            } else {
                testSignalEnabled1 = false;
                console.log('Opzione simulated jump deselezionata');
            }

            if (radio4.checked) {
                console.log('Opzione enableADCToneL');
                remoteTestEnabled = true;
                inputMode = true;
                resetView();
                if(send) updateConfig("mode", 3);
                const batch = {
                    t: 0,
                    v: [0]
                };
                onmessageEvent({ data: JSON.stringify(batch) });
            } else {
                remoteTestEnabled = false;
                console.log('Opzione ADCToneL deselezionata');
            }

            if (radio5.checked) {
                console.log('Opzione tono enableADCToneH');
                remoteTestTone = true;
                adcSignalEnabled = true;
                inputMode = true;
                resetView();
                testSignalTime = 0;
                updateSamplesPerBatch();
                if(send) updateConfig("mode", 2);
                const batch = {
                    t: 0,
                    v: [0]
                };
                onmessageEvent({ data: JSON.stringify(batch) });
            } else {
                console.log('Opzione ADCToneH deselezionata');
            }
        }
        // Aggiungi il gestore dell'evento "change" a ogni radio button
        radioButtons2.forEach(radio => {
            radio.addEventListener('change', handleRadioChange);
        });
//----------------------------------------------------------------------------------------------------------------------- OGGI -----------------------------			
       //----------------------------------------------------------------------------------------------------------------------- OGGI -----------------------------			
        updateConfig('freq', 1);

        // =====================================================
        // VARIABILI GLOBALI PER IL SISTEMA DI GAIN
        // =====================================================

        // Fattore di zoom per l'asse Y (1.0 = normale, >1.0 = zoom in, <1.0 = zoom out)
        let yGain = 1.0;

        // Variabili globali per la gestione della pressione continua
        let buttonPressIntervals = {};
        let buttonPressTimeouts = {};

        // =====================================================
        // FUNZIONI PRINCIPALI DI CONTROLLO GAIN
        // =====================================================

        /**
         * Aggiusta il gain aggiungendo o sottraendo un valore (controllo additivo)
         * @param {number} delta - Valore da aggiungere/sottrarre (1, -1, 10, -10)
         */
        function adjustGainBy(delta) {
            // Se auto-scale è attivo, non fare nulla - i tasti funzionano solo in modalità manuale
            if (autoScale) {
                console.log('Gain manuale disabilitato durante auto-scale');
                return;
            }
            
            // Calcola il nuovo gain aggiungendo il delta
            const newGain = yGain + delta;
            
            // Protezione più rigorosa: limiti più stretti per evitare crash
            if (newGain < 0.5 || newGain > 256) {
                console.log(`Gain ${newGain.toFixed(1)}x fuori dai limiti sicuri (0.5x - 50x)`);
                return; // Esce senza applicare se fuori limiti
            }
            
            // USA il centro CORRENTE della vista (dove hai navigato con W/S)
            const currentCenter = (yScale.max + yScale.min) / 2;
            
            // PRIMA aggiorna il gain globale
            yGain = newGain;
            
            // Calcola il nuovo range usando SEMPRE il range standard come riferimento
            const standardRange = 8388608; // Range di riferimento standard
            const newRange = standardRange / yGain;
            
            // Applica il nuovo range mantenendo il centro CORRENTE (dove sei navigato)
            yScale.min = currentCenter - newRange / 2;
            yScale.max = currentCenter + newRange / 2;
            
            // Verifica finale dei valori
            if (isNaN(yScale.min) || isNaN(yScale.max) || !isFinite(yScale.min) || !isFinite(yScale.max)) {
                console.log('Valori finali non validi, reset completo');
                yScale.min = 0;
                yScale.max = 8388608;
                yGain = 1.0;
            }
            
            // Aggiorna tutti i display che mostrano il gain
            updateGainDisplay();        
            updateAutoScaleGainDisplay(); 
            
            // Ridisegna il grafico per mostrare le modifiche
            if (inputMode) {
                drawPlotInc(); 
            } else {
                drawPlot();    
            }
            
            console.log(`Y Gain aggiustato di ${delta}: nuovo gain ${yGain.toFixed(2)}x, range: ${(yScale.max - yScale.min).toFixed(0)}, centro: ${currentCenter.toFixed(0)}`);
        }

        /**
         * Aggiusta il centro della vista spostando su/giù
         * @param {number} delta - Valore da aggiungere/sottrarre al centro (±500000)
         */
        function adjustCenterBy(delta) {
            // Se auto-scale è attivo, non fare nulla - i tasti funzionano solo in modalità manuale
            if (autoScale) {
                console.log('Controllo centro disabilitato durante auto-scale');
                return;
            }
            
            // Calcola il centro corrente
            const currentCenter = (yScale.max + yScale.min) / 2;
            const newCenter = currentCenter + delta;
            
            // Calcola il range corrente (mantienilo uguale)
            const currentRange = yScale.max - yScale.min;
            
            // Applica il nuovo centro mantenendo lo stesso range
            yScale.min = newCenter - currentRange / 2;
            yScale.max = newCenter + currentRange / 2;
            
            // Verifica che i valori risultanti siano ragionevoli
            if (isNaN(yScale.min) || isNaN(yScale.max) || !isFinite(yScale.min) || !isFinite(yScale.max)) {
                console.log('Valori di centro non validi, ripristino');
                yScale.min = 0;
                yScale.max = 8388608;
            }
            
            // Ridisegna il grafico per mostrare le modifiche
            if (inputMode) {
                drawPlotInc(); 
            } else {
                drawPlot();    
            }
            
            console.log(`Centro spostato di ${delta}: nuovo centro ${newCenter.toFixed(0)}, range: ${currentRange.toFixed(0)}`);
        }

        /**
         * Resetta il gain a 1.0x (valore normale)
         */
        function resetGain() {
            // Riporta il gain ai valori di default
            yGain = 1.0;
            
            // Cancella il buffer auto-scale per ripartire pulito
            yScaleBuffer = [];
            
            // RESET SEMPLICE: usa sempre valori standard fissi
            yScale.min = 0;
            yScale.max = 8388608;
            
            // Aggiorna tutti i display
            updateGainDisplay();
            updateAutoScaleGainDisplay();
            
            // Ridisegna il grafico
            if (inputMode) {
                drawPlotInc();
            } else {
                drawPlot();
            }
            
            console.log('Y Gain e scala Y resettati ai valori standard (0 - 8388608)');
        }

        // =====================================================
        // FUNZIONI DI CALCOLO E APPLICAZIONE GAIN
        // =====================================================

        /**
         * Calcola il gain "effettivo" basato sulla scala Y corrente
         * Utile per sapere quanto zoom ha applicato l'auto-scale
         */
        function calculateEffectiveGain() {
            const defaultRange = 8388608; // Range Y di default (da 0 a 8388608)
            const currentRange = yScale.max - yScale.min; // Range corrente
            
            // Più piccolo è il range, maggiore è il gain (zoom)
            return defaultRange / currentRange;
        }

        /**
         * Applica il gain manualmente alla scala Y quando auto-scale è disattivo
         */
        function applyGainToYScale() {
            // Trova il centro della vista corrente
            const centerY = (yScale.max + yScale.min) / 2;
            
            // Calcola il range corrente
            const currentRange = yScale.max - yScale.min;
            
            // Calcola il nuovo range applicando il gain
            // Gain maggiore = range più piccolo = più zoom
            const newRange = currentRange / yGain;
            
            // Aggiorna i limiti mantenendo il centro
            yScale.min = centerY - newRange / 2;
            yScale.max = centerY + newRange / 2;
            
            console.log(`Scala Y con gain ${yGain}x: ${yScale.min.toFixed(0)} - ${yScale.max.toFixed(0)}`);
        }

        // =====================================================
        // FUNZIONI DI AGGIORNAMENTO DISPLAY
        // =====================================================

        /**
         * Aggiorna il display del gain totale ("Total Gain: 15.2x")
         */
        function updateGainDisplay() {
            const currentGainElement = document.getElementById('currentGain');
            
            if (currentGainElement) {
                // Mostra il gain corrente
                currentGainElement.textContent = `Total Gain: ${yGain.toFixed(2)}x`;
                
                // Cambia colore in base al livello di gain
                if (yGain > 5) {
                    currentGainElement.style.color = '#dc2626'; // Rosso per gain alto
                } else if (yGain > 1) {
                    currentGainElement.style.color = '#0369a1'; // Blu per gain medio
                } else {
                    currentGainElement.style.color = '#059669'; // Verde per gain basso/zoom out
                }
            }
        }

        /**
         * Aggiorna il display del gain effettivo quando auto-scale è attivo
         */
        function updateEffectiveGainDisplay() {
            if (autoScale) {
                const effectiveGain = calculateEffectiveGain(); // Calcola il gain reale dall'auto-scale
                const autoScaleGainElement = document.getElementById('autoScaleGain');
                if (autoScaleGainElement) {
                    // Mostra solo il gain effettivo calcolato dall'auto-scale
                    autoScaleGainElement.textContent = `${effectiveGain.toFixed(2)}x`;
                    
                    // Colore basato sul gain effettivo
                    if (effectiveGain > 5) {
                        autoScaleGainElement.style.color = '#dc2626';
                    } else if (effectiveGain > 1) {
                        autoScaleGainElement.style.color = '#0369a1';
                    } else {
                        autoScaleGainElement.style.color = '#059669';
                    }
                }
            }
        }

        /**
         * Aggiorna il display del gain nell'area auto-scale
         * Mostra gain effettivo se auto-scale ON, gain manuale se auto-scale OFF
         */
        function updateAutoScaleGainDisplay() {
            const autoScaleGainElement = document.getElementById('autoScaleGain');
            if (autoScaleGainElement) {
                if (autoScale) {
                    // Auto-scale ATTIVO: mostra il gain che l'auto-scale ha calcolato
                    updateEffectiveGainDisplay();
                } else {
                    // Auto-scale DISATTIVO: mostra il gain manuale che stai controllando
                    autoScaleGainElement.textContent = `${yGain.toFixed(2)}x`;
                    
                    // Colore basato sul gain manuale
                    if (yGain > 5) {
                        autoScaleGainElement.style.color = '#dc2626';
                    } else if (yGain > 1) {
                        autoScaleGainElement.style.color = '#0369a1';
                    } else {
                        autoScaleGainElement.style.color = '#059669';
                    }
                }
            }
        }

        /**
         * Inizializza tutti i display del gain (chiamata al caricamento pagina)
         */
        function initializeGainDisplays() {
            updateGainDisplay();           // Inizializza "Total Gain"
            updateAutoScaleGainDisplay();  // Inizializza gain auto-scale
            updateYScaleInfo();           // Inizializza info scala Y
        }

        // =====================================================
        // FUNZIONI MODIFICATE PER INTEGRAZIONE GAIN
        // =====================================================

        /**
         * FUNZIONE PRINCIPALE: Aggiorna la scala Y durante lo streaming
         * Integrata con il sistema di gain
         */
        function updateYScale(newValues) {
            // Se auto-scale è disattivato, non fare nulla automaticamente
            if (!autoScale) return;
            
            // Aggiungi i nuovi valori al buffer per il calcolo della scala
            yScaleBuffer.push(...newValues);
            
            // Mantieni solo gli ultimi Y_SCALE_BUFFER_SIZE valori per performance
            if (yScaleBuffer.length > Y_SCALE_BUFFER_SIZE) {
                yScaleBuffer = yScaleBuffer.slice(-Y_SCALE_BUFFER_SIZE);
            }
            
            if (yScaleBuffer.length === 0) return;
            
            // Calcola min e max dai valori recenti
            const minValue = Math.min(...yScaleBuffer);
            const maxValue = Math.max(...yScaleBuffer);
            
            // Calcola il range base con margine del 10%
            const range = maxValue - minValue;
            const margin = Math.max(range * 0.1, 1000);
            
            // *** QUI È LA MAGIA DEL GAIN ***
            // Applica il gain al range: gain maggiore = range più piccolo = più zoom
            const baseRange = range + 2 * margin;
            const gainedRange = baseRange / yGain;
            
            // Centra la vista sui dati
            const centerValue = (minValue + maxValue) / 2;
            
            // Aggiorna gradualmente la scala per evitare salti bruschi
            const smoothFactor = 0.1;
            const targetMin = centerValue - gainedRange / 2;
            const targetMax = centerValue + gainedRange / 2;
            
            // Smooth transition verso i nuovi valori
            yScale.min = yScale.min + (targetMin - yScale.min) * smoothFactor;
            yScale.max = yScale.max + (targetMax - yScale.max) * smoothFactor;
            
            // Aggiorna il display per mostrare il gain effettivo in tempo reale
            updateEffectiveGainDisplay();
        }

        /**
         * Resetta la scala Y considerando il gain corrente
         */
        function resetYScale() {
            yScaleBuffer = []; // Cancella il buffer
            
            if (yGain === 1.0) {
                // Gain normale: usa i valori di default
                yScale.min = 0;
                yScale.max = 8388608;
            } else {
                // Gain diverso da 1.0: applica il gain ai valori di default
                const defaultCenter = 4194304; // Centro del range di default
                const defaultRange = 8388608;   // Range di default
                const gainedRange = defaultRange / yGain; // Applica il gain
                
                // Centra sul range di default ma con il gain applicato
                yScale.min = defaultCenter - gainedRange / 2;
                yScale.max = defaultCenter + gainedRange / 2;
            }
            
            console.log(`YScale resettata con gain ${yGain}x: ${yScale.min.toFixed(0)} - ${yScale.max.toFixed(0)}`);
        }

        /**
         * Gestisce il toggle dell'auto-scale
         * Integrata per gestire il passaggio gain automatico ↔ gain manuale
         */
        function toggleAutoScale() {
            autoScale = document.getElementById('autoScaleCheckbox').checked;
            console.log("Auto-scaling:", autoScale ? "abilitato" : "disabilitato");
            
            if (autoScale) {
                // Attivazione auto-scale: RESETTA il gain a 1.0 per evitare doppi effetti
                yGain = 1.0;
                
                // Aggiorna i display
                updateGainDisplay();
                updateAutoScaleGainDisplay();
                
                console.log('Auto-scale attivato - gain resettato a 1.0x');
            } else {
                // Disattivazione auto-scale: "congela" il gain corrente
                // Copia il gain effettivo dell'auto-scale come nuovo gain manuale
                const effectiveGain = calculateEffectiveGain();
                yGain = effectiveGain;
                
                // Aggiorna i display per mostrare il nuovo gain manuale
                updateGainDisplay();
                updateAutoScaleGainDisplay();
                
                console.log(`Gain copiato dall'auto-scale: ${effectiveGain.toFixed(2)}x`);
                
                // Ridisegna mantenendo esattamente la stessa vista
                if (inputMode) {
                    drawPlotInc();
                } else {
                    drawPlot();
                }
            }
        }

        /**
         * Aggiorna le info della scala Y mostrandone anche il gain
         */
        function updateYScaleInfo() {
            const infoElement = document.getElementById('yScaleInfo');
            if (infoElement) {
                infoElement.textContent = `Y Range: ${yScale.min.toFixed(0)} to ${yScale.max.toFixed(0)} (Gain: ${yGain.toFixed(2)}x), Current Y center: ${((yScale.min+yScale.max)/2).toFixed(0)}`;
            }
        }

        // =====================================================
        // FUNZIONI DI GESTIONE PRESSIONE CONTINUA
        // =====================================================

        /**
         * Avvia la pressione continua di un pulsante
         * @param {string} buttonId - ID univoco del pulsante
         * @param {Function} actionFunction - Funzione da eseguire ripetutamente
         * @param {number} initialDelay - Ritardo iniziale prima di iniziare la raffica (ms)
         * @param {number} repeatInterval - Intervallo tra le pressioni nella raffica (ms)
         */
        function startContinuousPress(buttonId, actionFunction, initialDelay = 300, repeatInterval = 100) {
            // Esegui immediatamente la prima azione
            actionFunction();
            
            // Avvia la raffica dopo il ritardo iniziale
            buttonPressTimeouts[buttonId] = setTimeout(() => {
                buttonPressIntervals[buttonId] = setInterval(actionFunction, repeatInterval);
            }, initialDelay);
        }

        /**
         * Ferma la pressione continua di un pulsante
         * @param {string} buttonId - ID univoco del pulsante
         */
        function stopContinuousPress(buttonId) {
            // Ferma il timeout iniziale se ancora attivo
            if (buttonPressTimeouts[buttonId]) {
                clearTimeout(buttonPressTimeouts[buttonId]);
                delete buttonPressTimeouts[buttonId];
            }
            
            // Ferma l'intervallo di ripetizione se attivo
            if (buttonPressIntervals[buttonId]) {
                clearInterval(buttonPressIntervals[buttonId]);
                delete buttonPressIntervals[buttonId];
            }
        }

        /**
         * Ferma tutte le pressioni continue attive
         */
        function stopAllContinuousPress() {
            for (let buttonId in buttonPressTimeouts) {
                clearTimeout(buttonPressTimeouts[buttonId]);
            }
            for (let buttonId in buttonPressIntervals) {
                clearInterval(buttonPressIntervals[buttonId]);
            }
            buttonPressTimeouts = {};
            buttonPressIntervals = {};
        }

        /**
         * Configura un pulsante per la pressione continua
         * @param {string} buttonId - ID del pulsante
         * @param {Function} actionFunction - Funzione da eseguire
         * @param {number} initialDelay - Ritardo iniziale (default: 300ms)
         * @param {number} repeatInterval - Intervallo ripetizione (default: 100ms)
         */
        function setupContinuousButton(buttonId, actionFunction, initialDelay = 300, repeatInterval = 100) {
            const button = document.getElementById(buttonId);
            if (!button) {
                console.warn(`Button ${buttonId} not found`);
                return;
            }
            
            // Mouse events
            button.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startContinuousPress(buttonId, actionFunction, initialDelay, repeatInterval);
                
                // Effetto visivo: pulsante premuto
                button.style.transform = 'scale(0.95)';
                button.style.opacity = '0.8';
            });
            
            button.addEventListener('mouseup', () => {
                stopContinuousPress(buttonId);
                
                // Ripristina effetto visivo
                button.style.transform = 'scale(1)';
                button.style.opacity = '1';
            });
            
            button.addEventListener('mouseleave', () => {
                stopContinuousPress(buttonId);
                
                // Ripristina effetto visivo
                button.style.transform = 'scale(1)';
                button.style.opacity = '1';
            });
            
            // Touch events per dispositivi mobili
            button.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startContinuousPress(buttonId, actionFunction, initialDelay, repeatInterval);
                
                // Effetto visivo
                button.style.transform = 'scale(0.95)';
                button.style.opacity = '0.8';
            });
            
            button.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopContinuousPress(buttonId);
                
                // Ripristina effetto visivo
                button.style.transform = 'scale(1)';
                button.style.opacity = '1';
            });
            
            button.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                stopContinuousPress(buttonId);
                
                // Ripristina effetto visivo
                button.style.transform = 'scale(1)';
                button.style.opacity = '1';
            });
        }

        /**
         * Crea e aggiunge i controlli di gain all'interfaccia CON PRESSIONE CONTINUA
        */
        function addYScaleControls() {
			const controlPanel = document.querySelector('.control-panel');
			
			const yScaleDiv = document.createElement('div');
			yScaleDiv.className = 'config-item yscale-controls';
			yScaleDiv.innerHTML = `
				<label><strong>Y Scale Controls:</strong></label>
				<button onclick="resetYScale()">Reset Y Scale</button>
				<button onclick="centerViewOnData()" style="background: #059669; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;">Center on Data</button>
				<label>
					<input type="checkbox" id="autoScaleCheckbox" checked onchange="toggleAutoScale()">
					Auto Scale Y (Gain: <span id="autoScaleGain" style="font-weight: bold; color: #0369a1;">1.0x</span>)
				</label>
				
				<!-- FRECCE DIREZIONALI PER NAVIGAZIONE DATI -->
				<div style="margin: 5px 0; display: flex; align-items: center; gap: 10px; background: #f0f8ff; padding: 8px; border-radius: 4px; border: 1px solid #0ea5e9;">
					<span style="font-size: 12px; color: #0369a1; font-weight: bold;">Navigazione dati:</span>
					
					<!-- Freccia sinistra (indietro nel tempo) -->
					<div id="leftDataArrow" style="display: none; align-items: center; gap: 5px; color: #dc2626; font-weight: bold;">
						<span style="font-size: 18px;">⬅️</span>
						<span style="font-size: 11px;">Usa - o ←</span>
					</div>
					
					<!-- Indicatore centrato -->
					<div id="centeredIndicator" style="display: none; align-items: center; gap: 5px; color: #059669; font-weight: bold;">
						<span style="font-size: 18px;">🎯</span>
						<span style="font-size: 11px;">Centrato</span>
					</div>
					
					<!-- Freccia destra (avanti nel tempo) -->
					<div id="rightDataArrow" style="display: none; align-items: center; gap: 5px; color: #dc2626; font-weight: bold;">
						<span style="font-size: 18px;">➡️</span>
						<span style="font-size: 11px;">Usa + o →</span>
					</div>
				</div>
				
				<div style="margin: 5px 0; display: flex; align-items: center; gap: 15px;">
					<label>Y Gain:</label>
					
					<!-- Prima coppia: +1/-1 -->
					<div style="display: flex; flex-direction: column; align-items: center;">
						<button id="gain-plus-1" style="border: 2px solid #0369a1; padding: 2px 8px; margin: 1px; background: #e0f2fe; cursor: pointer; font-size: 12px;">+</button>
						<span style="font-size: 10px; color: #0369a1; font-weight: bold;">+1/-1</span>
						<button id="gain-minus-1" style="border: 2px solid #0369a1; padding: 2px 8px; margin: 1px; background: #e0f2fe; cursor: pointer; font-size: 12px;">-</button>
					</div>
					
					<!-- Seconda coppia: +10/-10 -->
					<div style="display: flex; flex-direction: column; align-items: center;">
						<button id="gain-plus-10" style="border: 2px solid #dc2626; padding: 2px 8px; margin: 1px; background: #fee2e2; cursor: pointer; font-size: 12px;">+</button>
						<span style="font-size: 10px; color: #dc2626; font-weight: bold;">+10/-10</span>
						<button id="gain-minus-10" style="border: 2px solid #dc2626; padding: 2px 8px; margin: 1px; background: #fee2e2; cursor: pointer; font-size: 12px;">-</button>
					</div>
					
					<!-- Terza coppia: centro normale -->
					<div style="display: flex; flex-direction: column; align-items: center;">
						<button id="center-plus-250k" style="border: 2px solid #059669; padding: 2px 8px; margin: 1px; background: #d1fae5; cursor: pointer; font-size: 12px;">+</button>
						<span style="font-size: 10px; color: #059669; font-weight: bold;">Centro</span>
						<button id="center-minus-250k" style="border: 2px solid #059669; padding: 2px 8px; margin: 1px; background: #d1fae5; cursor: pointer; font-size: 12px;">-</button>
					</div>
					
					<!-- QUARTA coppia: centro fine (5x più preciso) -->
					<div style="display: flex; flex-direction: column; align-items: center;">
						<button id="center-plus-50k" style="border: 2px solid #7c3aed; padding: 2px 8px; margin: 1px; background: #f3e8ff; cursor: pointer; font-size: 12px;">+</button>
						<span style="font-size: 10px; color: #7c3aed; font-weight: bold;">Fine</span>
						<button id="center-minus-50k" style="border: 2px solid #7c3aed; padding: 2px 8px; margin: 1px; background: #f3e8ff; cursor: pointer; font-size: 12px;">-</button>
					</div>
					
					<button onclick="resetGain()" style="margin-left: 10px; background: #ff6b6b; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;">Reset</button>
				</div>
				<div style="margin: 5px 0;">
					<span id="currentGain" style="font-weight: bold; color: #0369a1;">Total Gain: 1.0x</span>
				</div>
				<div id="yScaleInfo" class="yscale-info">Y Range: 0 to 8388608</div>
			`;
			
			controlPanel.appendChild(yScaleDiv);
			
			// Configurazione event listeners per pressione continua (come prima)
			setTimeout(() => {
				setupContinuousButton('gain-plus-1', () => adjustGainBy(1));
				setupContinuousButton('gain-minus-1', () => adjustGainBy(-1));
				setupContinuousButton('gain-plus-10', () => adjustGainBy(10), 400, 150);
				setupContinuousButton('gain-minus-10', () => adjustGainBy(-10), 400, 150);
				setupContinuousButton('center-plus-250k', () => {
					adjustCenterBy(50000);
				}, 300, 80);
				setupContinuousButton('center-minus-250k', () => {
					adjustCenterBy(-50000);
				}, 300, 80);
				setupContinuousButton('center-plus-50k', () => {
					adjustCenterBy(1000);
				}, 300, 60);
				setupContinuousButton('center-minus-50k', () => {
					adjustCenterBy(-1000);
				}, 300, 60);
				
				initializeGainDisplays();
			}, 100);
		}
        // =====================================================
        // TASTI RAPIDI PER IL GAIN (CON ESC DI EMERGENZA)
        // =====================================================

        // Aggiunge controlli con tasti rapidi per il gain
        document.addEventListener('keydown', function(event) {
            // Funziona solo se non stai scrivendo in un campo di testo
            if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
                switch(event.key) {
                    case 'Escape':
                        stopAllContinuousPress(); // Ferma tutto in caso di emergenza
                        console.log('🛑 Tutte le pressioni continue fermate con ESC');
                        event.preventDefault();
                        break;
                    case 'ArrowUp':
                        adjustGainBy(1); // Aumenta di 1
                        event.preventDefault();
                        break;
                    case 'ArrowDown':
                        adjustGainBy(-1); // Diminuisce di 1
                        event.preventDefault();
                        break;
                    case 'PageUp':
                        adjustGainBy(10); // Aumenta di 10
                        event.preventDefault();
                        break;
                    case 'PageDown':
                        adjustGainBy(-10); // Diminuisce di 10
                        event.preventDefault();
                        break;
                    case '1':
                        adjustGainBy(1); // Aumenta di 1
                        event.preventDefault();
                        break;
                    case '2':
                        adjustGainBy(-1); // Diminuisce di 1
                        event.preventDefault();
                        break;
                    case '5':
                        adjustGainBy(10); // Aumenta di 10
                        event.preventDefault();
                        break;
                    case '0':
                        adjustGainBy(-10); // Diminuisce di 10
                        event.preventDefault();
                        break;
                    case 'w':
                    case 'W':
                        adjustCenterBy(150000); // Centro su (normale)
                        event.preventDefault();
                        break;
                    case 's':
                    case 'S':
                        adjustCenterBy(-150000); // Centro giù (normale)
                        event.preventDefault();
                        break;
                    // NUOVI tasti per controllo centro fine
                    case 'q':
                    case 'Q':
                        adjustCenterBy(1000); // Centro su (fine, 5x più preciso)
                        event.preventDefault();
                        break;
                    case 'a':
                    case 'A':
                        adjustCenterBy(-1000); // Centro giù (fine, 5x più preciso)
                        event.preventDefault();
                        break;
                    case 'r':
                    case 'R':
                        resetGain(); // Resetta tutto a 1.0x
                        event.preventDefault();
                        break;
                }
            }
        });

        // =====================================================
        // CLEANUP AUTOMATICO ALLA CHIUSURA PAGINA
        // =====================================================

        window.addEventListener('beforeunload', () => {
            stopAllContinuousPress();
        });

//----------------------------------------------------------------------------------------------------------------------- END OGGI-----------------------------
//----------------------------------------------------------------------------------------------------------------------- END OGGI-----------------------------
        function resizeCanvas() {
            console.log("resizeCanvas");
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            if (inputMode){
                drawPlotInc();
                //currBatchIndex = 20;
            }else{
                playRecord();
             }
        }
/*
        function detectJumpThresholds(recordBuffer, sampleRate) {
            let result = {t1: null, t2: null, t3: null, t4: null, t5: null};
            let minDerivative = Infinity;
            let maxDerivative = -Infinity;
            let precBatchTime;
            let currBatchTime;
            let batchLen;
            let lastForce = null;
            result.t1 = null;
            result.t2 = null;
            result.t3 = null;
            result.t4 = null;
            result.t5 = null;

            // Calcolo peso statico
            let staticWeight = 0;
            let staticCount = 0;
            for(let batchIdx = 0; batchIdx < recordBuffer.length && staticCount < 20; batchIdx++) {
                const batch = recordBuffer[batchIdx];
                for(let i = 0; i < batch.v.length && staticCount < 20; i++) {
                    staticWeight +=  calculateValue(batch.v[i]);
                    staticCount++;
                }
            }
            staticWeight /= staticCount;

            const dt0 = 1/sampleRate;
            precBatchTime = parseInt(recordBuffer[0].t, 16) / 1000000 - dt0;
            filterh.predict();
            lastForce = filterh.update(calculateValue(recordBuffer[0].v[0]));
            batchLen = recordBuffer[0].v.length;
            // Analisi principale
            let lastDerivative = null;            
            for(let batchIdx = 0; batchIdx < recordBuffer.length; batchIdx++) {
                const batch = recordBuffer[batchIdx];

                // Calcola dt medio dai primi due batch
                currBatchTime = parseInt(recordBuffer[batchIdx].t, 16) / 1000000;
                const dt = (currBatchTime - precBatchTime) / batchLen;
                
                for(let i = 0; i < batch.v.length; i++) {                   
                    filterh.predict();
                    let force = filterh.update(calculateValue(batch.v[i]));
                    
                    const currentTime = batchTime + (i * dt);
                    const derivative = (force - lastForce) / dt;
                    
                    if(result.t1 === null && (derivative > 1000 || derivative < -1000)) {
                        result.t1 = currentTime;
                    }

    

                    if(result.t2 == null && result.t1 !== null && derivative > 0 && force > staticWeight && lastForce <= staticWeight) {
                        result.t2 = currentTime;
                    }
                    
                    if(result.t3 == null && result.t2 !== null && derivative < 0 && force < staticWeight && lastForce >= staticWeight) {
                        result.t3 = currentTime;
                    }

                    if(result.t4 == null && result.t3 !== null && result.t4 === null && force < 0.05 * staticWeight && derivative < -100) {
                        result.t4 = currentTime;
                    }
                    
                    if(result.t5 == null && result.t4 !== null && result.t5 === null && force > 0 && derivative > 10) {
                        result.t5 = currentTime;
                    }
                    
                    lastForce = force;
                    lastDerivative = derivative;
                }

                precBatchTime = currBatchTime;
            }
            
            console.log(`t1: ${result.t1} - t2: ${result.t2} - t3: ${result.t3} - t4: ${result.t4} - t5: ${result.t5}`);
            return result;
        }
*/
		
        function analyzeJump(recordBuffer, sampleRate) {
            const times = detectJumpThresholds(recordBuffer, sampleRate, 1);
            thresholds = times;

            const g = 9.81;
            const Fstatico = 700; 
            const sensitivity = 50000;
            
            // Calcolo velocità iniziale (t1->t4)
            let vIniziale = 0;
            let dt = 1/sampleRate;
            
            // Calcolo velocità di caduta (t5->stabilizzazione)
            let vCaduta = 0;
            let stabilized = false;
            let tStabilizzazione = times.t5;
            
            for(let batchIdx = 0; batchIdx < recordBuffer.length; batchIdx++) {
                const batch = recordBuffer[batchIdx];
                const batchTime = parseInt(batch.t, 16) / 1000000;
                
                for(let i = 0; i < batch.v.length; i++) {
                    let value = calculateValue(batch.v[i]);
                    
                    filtera.predict();
                    value = filtera.update(value);
                    const force = (value * Fstatico) / sensitivity;
                    
                    // Integrazione pre-salto
                    if(batchTime >= times.t1 && batchTime <= times.t4) {
                        vIniziale += g * ((force - Fstatico) / Fstatico) * dt;
                    }
                    
                    // Cerca punto di stabilizzazione post-atterraggio
                    if(batchTime > times.t5 && !stabilized) {
                        if(Math.abs(force - Fstatico) < Fstatico * 0.05) { // ±5% del peso statico
                            stabilized = true;
                            tStabilizzazione = batchTime;
                        }
                        // Integra fino alla stabilizzazione
                        vCaduta += g * ((force - Fstatico) / Fstatico) * dt;
                    }
                }
            }

            const flightTime = times.t5 - times.t4;
            const h_flight = (g * flightTime * flightTime) / 8;
            const h_velocity = (vIniziale * vIniziale) / (2 * g);
            const h_landing = (vCaduta * vCaduta) / (2 * g);

            return {
                flightTime,
                height_from_time: h_flight,
                height_from_velocity: h_velocity,
                height_from_landing: h_landing,
                initial_velocity: vIniziale,
                landing_velocity: vCaduta,
                stabilization_time: tStabilizzazione - times.t5,
                thresholdTimes: times
            };
        }

        function printJumpReport(data) {
            // Console report
            console.table({
                "Flight Time": `${(data.flightTime * 1000).toFixed(1)} ms`,
                "Height (from time)": `${(data.height_from_time * 100).toFixed(1)} cm`,
                "Height (from velocity)": `${(data.height_from_velocity * 100).toFixed(1)} cm`, 
                "Height (from landing)": `${(data.height_from_landing * 100).toFixed(1)} cm`,
                "Initial Velocity": `${data.initial_velocity.toFixed(2)} m/s`,
                "Landing Velocity": `${data.landing_velocity.toFixed(2)} m/s`,
                "Stabilization Time": `${(data.stabilization_time * 1000).toFixed(1)} ms`,
                "Time Events": {
                    "Start of Movement (t1)": `${(data.thresholdTimes.t1 * 1000).toFixed(1)} ms`,
                    "Max Descent Speed (t2)": `${(data.thresholdTimes.t2 * 1000).toFixed(1)} ms`, 
                    "Max Ascent Speed (t3)": `${(data.thresholdTimes.t3 * 1000).toFixed(1)} ms`,
                    "Takeoff (t4)": `${(data.thresholdTimes.t4 * 1000).toFixed(1)} ms`,
                    "Landing (t5)": `${(data.thresholdTimes.t5 * 1000).toFixed(1)} ms`
                }
            });

            // HTML report
            const div = document.createElement('div');
            div.innerHTML = `
                <div class="jump-report" style="font-family: Arial; padding: 20px; max-width: 600px; margin: auto;">
                    <h2>Jump Analysis Report</h2>
                    
                    <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
                        <h3>Jump Heights</h3>
                        <p>From Flight Time: <strong>${(data.height_from_time * 100).toFixed(1)} cm</strong></p>
                        <p>From Initial Velocity: <strong>${(data.height_from_velocity * 100).toFixed(1)} cm</strong></p>
                        <p>From Landing Force: <strong>${(data.height_from_landing * 100).toFixed(1)} cm</strong></p>
                    </div>

                    <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
                        <h3>Time Metrics</h3>
                        <p>Flight Time: <strong>${(data.flightTime * 1000).toFixed(1)} ms</strong></p>
                        <p>Stabilization Time: <strong>${(data.stabilization_time * 1000).toFixed(1)} ms</strong></p>
                    </div>

                    <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
                        <h3>Velocity Metrics</h3>
                        <p>Initial Velocity: <strong>${data.initial_velocity.toFixed(2)} m/s</strong></p>
                        <p>Landing Velocity: <strong>${data.landing_velocity.toFixed(2)} m/s</strong></p>
                    </div>

                    <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
                        <h3>Time Events</h3>
                        <p>Start of Movement (t1): <strong>${(data.thresholdTimes.t1 * 1000).toFixed(1)} ms</strong></p>
                        <p>Max Descent Speed (t2): <strong>${(data.thresholdTimes.t2 * 1000).toFixed(1)} ms</strong></p>
                        <p>Max Ascent Speed (t3): <strong>${(data.thresholdTimes.t3 * 1000).toFixed(1)} ms</strong></p>
                        <p>Takeoff (t4): <strong>${(data.thresholdTimes.t4 * 1000).toFixed(1)} ms</strong></p>
                        <p>Landing (t5): <strong>${(data.thresholdTimes.t5 * 1000).toFixed(1)} ms</strong></p>
                    </div>
                </div>
            `;
            
            document.body.appendChild(div);
            return div;
        }
		// =====================================================
		// SISTEMA DI SALVATAGGIO/CARICAMENTO AVANZATO CON METADATI
		// =====================================================
		
				// Modifica la funzione loadRecord per gestire i metadati (RETROCOMPATIBILE)
		async function loadRecord(file) {
			console.log("loadRecordWithMetadata - Retrocompatibile");
			if (!file) return;
			
			try {
				const text = await file.text();
				const lines = text.split('\n').filter(line => line.trim());
				
				let metadata = null;
				let dataStartIndex = 0;
				let hasMetadata = false;
				
				// Controlla se la prima riga contiene metadati
				if (lines.length > 0) {
					try {
						const firstLine = JSON.parse(lines[0]);
						if (firstLine.type === "METADATA") {
							metadata = firstLine;
							dataStartIndex = 1;
							hasMetadata = true;
							console.log('✅ File CON metadati trovato:', metadata);
						}
					} catch (e) {
						console.log('📁 File SENZA metadati (formato vecchio) - Retrocompatibilità attiva');
					}
				}
				
				// Carica i batch (saltando la prima riga se contiene metadati)
				recordBuffer = lines.slice(dataStartIndex).map(line => {
					const hexBatch = JSON.parse(line);
					return {
						t: hexBatch.t,
						v: hexBatch.v
					};
				});
				
				// Gestione metadati con retrocompatibilità
				if (hasMetadata) {
					// File nuovo con metadati: applica i metadati salvati
					applyMetadataToView(metadata);
					showToast('File caricato con metadati salvati', 'success');
				} else {
					// File vecchio senza metadati: usa impostazioni di default ma segna come "da salvare"
					console.log('🔄 File vecchio senza metadati - Applicazione impostazioni di default');
					
					// Resetta a valori di default
					yGain = 1.0;
					resetYScale();
					
					// Aggiorna tutti i display
					updateGainDisplay();
					updateAutoScaleGainDisplay();
					updateYScaleInfo();
					
					// Segna che il file necessita di metadati al prossimo salvataggio
					markFileAsNeedingMetadata();
					
					showToast('File vecchio caricato - Metadati saranno aggiunti al salvataggio', 'info');
				}
				
				console.log(`📊 Caricati ${recordBuffer.length} batch - Metadati: ${hasMetadata ? 'Presenti' : 'Assenti'}`);
				
			} catch (error) {
				console.error('❌ Errore durante il caricamento del record:', error);
				showToast('Errore nel caricamento del file', 'error');
				alert('Errore nel caricamento del file. Verifica che sia un file valido.');
			}
		}
		
		document.getElementById('recordFileInput').addEventListener('change', function(e) {
			loadRecord(e.target.files[0]);
		});
		
		document.getElementById('play').addEventListener('click', function(e) {
			playRecord();
		});
		
		// Modifica playRecord per usare la nuova versione
		function playRecord() {
			playRecordWithMetadata(); // <-- Usa la nuova funzione
		}
		
		// Aggiungi questa funzione per salvare con metadati
		function saveRecordedBatchesWithMetadata() {
			// Calcola il centro corrente della vista Y
			const currentCenter = (yScale.max + yScale.min) / 2;
			
			// Crea il JSON dei metadati
			const metadata = {
				type: "METADATA",
				version: "1.0",
				timestamp: new Date().toISOString(),
				yGain: yGain,
				currentCenter: currentCenter,
				yScaleMin: yScale.min,
				yScaleMax: yScale.max,
				sampleRate: SAMPLE_RATE,
				bufferDurationSec: bufferDurationSec,
				totalBatches: recordBuffer.length,
				notes: "File saved with Y-scale metadata for accurate playback"
			};
			
			// Crea il contenuto del file: prima i metadati, poi i batch
			let content = JSON.stringify(metadata) + '\n';
			
			// Aggiungi tutti i batch
			content += recordBuffer.map(batch => {
				const hexBatch = {
					t: batch.t,
					v: batch.v
				};
				return JSON.stringify(hexBatch);
			}).join('\n');
			
			// Salva il file
			const blob = new Blob([content], { type: 'text/plain' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = getDefaultFileName();
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			URL.revokeObjectURL(url);
			
			console.log('File salvato con metadati:', metadata);
		}

		// Nuova funzione per segnare i file senza metadati
		let fileNeedsMetadata = false;

		function markFileAsNeedingMetadata() {
			fileNeedsMetadata = true;
			
			// Mostra un indicatore visivo che il file verrà aggiornato
			const saveBtn = document.getElementById('saveMetadataBtn');
			if (saveBtn) {
				saveBtn.style.background = '#f59e0b'; // Arancione per indicare "da aggiornare"
				saveBtn.title = 'File vecchio caricato - Clicca per salvare con metadati aggiornati';
				saveBtn.textContent = 'Add Metadata';
				
				// Lampeggia brevemente per attirare l'attenzione
				let blinkCount = 0;
				const blinkInterval = setInterval(() => {
					saveBtn.style.opacity = saveBtn.style.opacity === '0.5' ? '1' : '0.5';
					blinkCount++;
					if (blinkCount >= 6) { // 3 lampeggi
						clearInterval(blinkInterval);
						saveBtn.style.opacity = '1';
					}
				}, 300);
			}
			
			console.log('🏷️ File marcato come bisognoso di metadati');
		}

		// Nuova funzione per applicare i metadati alla vista
		function applyMetadataToView(metadata) {
			console.log('Applicazione metadati alla vista...');
			
			// Ripristina il gain salvato
			if (metadata.yGain !== undefined) {
				yGain = metadata.yGain;
				console.log(`Gain ripristinato: ${yGain}x`);
			}
			
			// Ripristina la scala Y salvata
			if (metadata.yScaleMin !== undefined && metadata.yScaleMax !== undefined) {
				yScale.min = metadata.yScaleMin;
				yScale.max = metadata.yScaleMax;
				console.log(`Scala Y ripristinata: ${yScale.min} - ${yScale.max}`);
			} else if (metadata.currentCenter !== undefined) {
				// Fallback: usa centro e gain per ricostruire la scala
				const standardRange = 8388608;
				const newRange = standardRange / yGain;
				yScale.min = metadata.currentCenter - newRange / 2;
				yScale.max = metadata.currentCenter + newRange / 2;
				console.log(`Scala Y ricostruita da centro: ${yScale.min} - ${yScale.max}`);
			}
			
			// Ripristina sample rate se diverso
			if (metadata.sampleRate !== undefined && metadata.sampleRate !== SAMPLE_RATE) {
				SAMPLE_RATE = metadata.sampleRate;
				document.getElementById('sampleRate').value = SAMPLE_RATE;
				console.log(`Sample rate ripristinato: ${SAMPLE_RATE}`);
			}
			
			// Aggiorna tutti i display
			updateGainDisplay();
			updateAutoScaleGainDisplay();
			updateYScaleInfo();
			
			// Mostra info sui metadati caricati
			showMetadataInfo(metadata);
		}

		// Funzione per mostrare le informazioni sui metadati caricati
		function showMetadataInfo(metadata) {
			const info = `
		📁 File caricato con metadati:
		• Gain: ${metadata.yGain}x
		• Centro Y: ${metadata.currentCenter}
		• Range Y: ${metadata.yScaleMin} - ${metadata.yScaleMax}
		• Sample Rate: ${metadata.sampleRate} Hz
		• Batch totali: ${metadata.totalBatches}
		• Salvato: ${new Date(metadata.timestamp).toLocaleString()}
			`;
			
			console.log(info);
			
			// Mostra temporaneamente un toast
			showToast('Metadati caricati con successo!', 'success');
		}

		// Funzione per salvare solo i metadati correnti (tasto Save) - RETROCOMPATIBILE
		function saveCurrentMetadata() {
			if (recordBuffer.length === 0) {
				alert('Nessun dato da salvare. Carica prima una traccia.');
				return;
			}
			
			const currentCenter = (yScale.max + yScale.min) / 2;
			
			const metadata = {
				type: "METADATA",
				version: "1.0",
				timestamp: new Date().toISOString(),
				yGain: yGain,
				currentCenter: currentCenter,
				yScaleMin: yScale.min,
				yScaleMax: yScale.max,
				sampleRate: SAMPLE_RATE,
				bufferDurationSec: bufferDurationSec,
				totalBatches: recordBuffer.length,
				notes: fileNeedsMetadata ? 
					"Legacy file updated with metadata for first time" : 
					"Updated metadata for existing trace"
			};
			
			// Ricrea il file con i nuovi metadati
			let content = JSON.stringify(metadata) + '\n';
			
			// Aggiungi tutti i batch esistenti
			content += recordBuffer.map(batch => {
				const hexBatch = {
					t: batch.t,
					v: batch.v
				};
				return JSON.stringify(hexBatch);
			}).join('\n');
			
			// Determina il nome del file
			const blob = new Blob([content], { type: 'text/plain' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			
			// Nome file appropriato
			let fileName;
			if (fileNeedsMetadata) {
				// File vecchio: aggiungi suffisso _with_metadata
				const originalName = getDefaultFileName();
				const nameParts = originalName.split('.');
				if (nameParts.length > 1) {
					nameParts[nameParts.length - 2] += '_with_metadata';
				} else {
					nameParts[0] += '_with_metadata';
				}
				fileName = nameParts.join('.');
			} else {
				// File già con metadati: aggiungi suffisso _updated
				const originalName = getDefaultFileName();
				const nameParts = originalName.split('.');
				if (nameParts.length > 1) {
					nameParts[nameParts.length - 2] += '_updated';
				} else {
					nameParts[0] += '_updated';
				}
				fileName = nameParts.join('.');
			}
			
			a.download = fileName;
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			URL.revokeObjectURL(url);
			
			// Reset del flag e aggiornamento UI
			if (fileNeedsMetadata) {
				fileNeedsMetadata = false;
				const saveBtn = document.getElementById('saveMetadataBtn');
				if (saveBtn) {
					saveBtn.style.background = '#059669'; // Verde normale
					saveBtn.title = 'Salva gain e centro correnti nel file';
					saveBtn.textContent = 'Save Metadata';
				}
				showToast('File vecchio aggiornato con metadati!', 'success');
			} else {
				showToast('Metadati aggiornati e salvati!', 'success');
			}
			
			console.log('💾 Metadati salvati:', metadata);
		}

		// Funzione di utilità per mostrare notifiche toast
		function showToast(message, type = 'info') {
			// Rimuovi toast precedenti
			const existingToast = document.getElementById('toast');
			if (existingToast) {
				existingToast.remove();
			}
			
			// Crea nuovo toast
			const toast = document.createElement('div');
			toast.id = 'toast';
			toast.style.cssText = `
				position: fixed;
				top: 20px;
				right: 20px;
				padding: 15px 20px;
				border-radius: 5px;
				color: white;
				font-weight: bold;
				z-index: 10000;
				transition: opacity 0.3s;
				${type === 'success' ? 'background: #059669;' : 
				  type === 'error' ? 'background: #dc2626;' : 
				  'background: #0369a1;'}
			`;
			toast.textContent = message;
			
			document.body.appendChild(toast);
			
			// Rimuovi dopo 3 secondi
			setTimeout(() => {
				toast.style.opacity = '0';
				setTimeout(() => toast.remove(), 300);
			}, 3000);
		}

		// Modifica la funzione playRecord per usare i metadati
		function playRecordWithMetadata() {
			// Disabilita il modo test se attivo
			adcSignalEnabled = false;
			testSignalEnabled0 = false;
			testSignalEnabled1 = false;
			if(isStreaming) {
				toggleStreaming();
			}
			inputMode = false;
			recordBuffer = recordBuffer.slice(0, maxBufferSize);
			currPlayIndex = 0;
			
			// Centratura intelligente sui dati (come prima)
			if (recordBuffer.length > 0) {
				const firstBatch = recordBuffer[0];
				const lastBatch = recordBuffer[recordBuffer.length - 1];
				const dataStartTime = parseInt(firstBatch.t, 16);
				const dataEndTime = parseInt(lastBatch.t, 16);
				const dataCenterTime = (dataStartTime + dataEndTime) / 2;
				
				const currentTimeWindow = timebaseDiv * DIVISIONS_X * 1000000;
				xScale.min = dataCenterTime - currentTimeWindow / 2;
				xScale.max = dataCenterTime + currentTimeWindow / 2;
				
				console.log(`Playback centrato: centro dati=${dataCenterTime}, finestra=${currentTimeWindow}`);
			}
			
			// I metadati Y sono già stati applicati durante il caricamento
			// Non fare auto-scaling automatico qui
			
			// Analisi del salto e report
			report = analyzeJump(recordBuffer, SAMPLE_RATE);   
			printJumpReport(report);  
			drawPlot();       
			scrollView(0);
		}

		// Funzione per aggiornare i controlli HTML
		function addSaveLoadControls() {
			// Trova i controlli esistenti per il recording
			const recordBtn = document.getElementById('recordBtn');
			const loadRecordBtn = document.getElementById('loadRecordBtn');
			
			if (recordBtn && loadRecordBtn) {
				// Modifica il testo del load button per chiarire che carica con metadati
				loadRecordBtn.title = 'Carica traccia con metadati Y-scale';
				
				// Crea il pulsante Save per salvare metadati aggiornati
				const saveBtn = document.createElement('button');
				saveBtn.id = 'saveMetadataBtn';
				saveBtn.textContent = 'Save Metadata';
				saveBtn.title = 'Salva gain e centro correnti nel file';
				saveBtn.style.cssText = `
					background: #059669;
					color: white;
					border: none;
					padding: 4px 8px;
					border-radius: 3px;
					cursor: pointer;
					margin-left: 5px;
				`;
				saveBtn.onclick = saveCurrentMetadata;
				
				// Inserisci il pulsante dopo il load button
				loadRecordBtn.parentNode.insertBefore(saveBtn, loadRecordBtn.nextSibling);
				
				console.log('Controlli di salvataggio/caricamento con metadati aggiunti');
			}
		}

		// Modifica le funzioni esistenti per usare le nuove versioni
		function toggleRecording() {
			if (!isRecording) {
				// Start recording
				recordBuffer = []; // Reset buffer
				isRecording = true;
				document.getElementById('recordBtn').innerHTML = 'Stop Recording';
			} else {
				// Stop and save WITH METADATA
				isRecording = false;
				saveRecordedBatchesWithMetadata(); // <-- Usa la nuova funzione
				document.getElementById('recordBtn').innerHTML = 'Start Recording';
			}
		}
		// =====================================================
		// ESEMPI DI FORMATO FILE CON METADATI
		// =====================================================

		/*
		ESEMPIO di file salvato con metadati:

		{"type":"METADATA","version":"1.0","timestamp":"2025-07-01T10:30:00.000Z","yGain":60,"currentCenter":36304,"yScaleMin":-33601,"yScaleMax":106209,"sampleRate":30000,"bufferDurationSec":10,"totalBatches":500,"notes":"File saved with Y-scale metadata for accurate playback"}
		{"t":1655484153000000,"v":["400000","400001","400002",...]}
		{"t":1655484153005000,"v":["400010","400011","400012",...]}
		...

		La prima riga contiene sempre i metadati (riconoscibile da "type":"METADATA")
		Le righe successive contengono i batch di dati come prima
		*/
	
		// Funzione per aggiungere i controlli metadati
		function addMetadataControls() {
			const controlPanel = document.querySelector('.control-panel');
			
			// Trova i controlli di recording esistenti
			const recordBtn = document.getElementById('recordBtn');
			const loadRecordBtn = document.getElementById('loadRecordBtn');
			
			if (recordBtn && loadRecordBtn) {
				// Aggiungi i nuovi pulsanti
				const saveBtn = document.createElement('button');
				saveBtn.id = 'saveMetadataBtn';
				saveBtn.textContent = 'Save with Metadata';
				saveBtn.onclick = saveCurrentMetadata;
				saveBtn.style.cssText = `
					background: #059669;
					color: white;
					border: none;
					padding: 4px 8px;
					border-radius: 3px;
					cursor: pointer;
					margin-left: 5px;
				`;
							
				// Inserisci i pulsanti
				loadRecordBtn.parentNode.insertBefore(saveBtn, loadRecordBtn.nextSibling);
				console.log('✅ Controlli metadati aggiunti');
			}
		}
		
		// Funzione per creare template metadati vuoto
		function createMetadataTemplate() {
			const template = {
				type: "METADATA",
				version: "1.0",
				timestamp: new Date().toISOString(),
				yGain: 1.0,
				currentCenter: 4194304,
				yScaleMin: 0,
				yScaleMax: 8388608,
				sampleRate: 30000,
				bufferDurationSec: 10,
				totalBatches: 0,
				autoScale: true,
				notes: "Template metadati - modifica i valori secondo necessità"
			};
			
			return JSON.stringify(template, null, 2);
		}
		
		/**
		 * Formatta la distanza temporale in modo leggibile
		 */
		function formatTimeDistance(microseconds) {
			if (microseconds > 1000000) {
				return `${(microseconds / 1000000).toFixed(1)}s`;
			} else if (microseconds > 1000) {
				return `${(microseconds / 1000).toFixed(1)}ms`;
			} else {
				return `${microseconds.toFixed(0)}μs`;
			}
		}
		
		function centerViewOnData() {
			 if (!inputMode && recordBuffer.length > 0) {
				const firstBatch = recordBuffer[0];
				const lastBatch = recordBuffer[recordBuffer.length - 1];
				
				const dataStartTime = parseInt(firstBatch.t, 16);
				const dataEndTime = parseInt(lastBatch.t, 16);
				const dataCenterTime = (dataStartTime + dataEndTime) / 2;
				
				const currentTimeWindow = timebaseDiv * DIVISIONS_X * 1000000;
				
				xScale.min = dataCenterTime - currentTimeWindow / 2;
				xScale.max = dataCenterTime + currentTimeWindow / 2;
				
				drawPlot();
				console.log(`Vista centrata automaticamente sui dati: centro=${dataCenterTime}`);
			}
		}

        function scrollView(deltaMs) {
			console.log("scrollView: "+deltaMs);
			if (recordBuffer.length === 0) return;

			const timeWindow = timebaseDiv * DIVISIONS_X * 1000000;
			console.log("scrollView timeWindow: "+timeWindow);
			
			xScale.min += deltaMs;
			xScale.max = xScale.min + timeWindow;
			console.log("scrollView xScale.min: "+xScale.min);
			console.log("scrollView xScale.max: "+xScale.max);
			
			drawPlot();
		}

        function drawThresholds(times) {
            if (recordBuffer.length > 0) {
                ctx.save();
                
                // Linee
                ctx.strokeStyle = 'green';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                
                // Testo
                ctx.font = '12px Arial';
                ctx.fillStyle = 'green';
                ctx.textAlign = 'left';
                ctx.setLineDash([]); // Rimuove tratteggio per il testo
                
                const labels = {
                    t1: 'T1: Start',
                    t2: 'T2: Max Down',
                    t3: 'T3: Max Up', 
                    t4: 'T4: Takeoff',
                    t5: 'T5: Landing'
                };
                
                let count = 0;
                for (const [key, label] of Object.entries(labels)) {
                    if (times[key]) {
                        const x = timeToScreen(times[key] * 1000000);
                        // Linea
                        ctx.beginPath();
                        ctx.moveTo(x, padding);
                        ctx.lineTo(x, canvas.height - padding);
                        ctx.stroke();
                        
                        // Etichetta
                        ctx.fillText(label, x + 5, padding + 20 + count);
                    }
                    count +=10;
                }
                
                ctx.restore();
                console.log("Times:", times);
                console.log("Window:", {min: xScale.min, max: xScale.max});
            }
        }

        function drawScrollLimits() {
            if (recordBuffer.length > 0) {
                const firstTime = recordBuffer[0].t;
                const lastTime = recordBuffer[recordBuffer.length - 1].t;
                
                ctx.save();
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);               

                // Limite sinistro
                const x1 = timeToScreen(firstTime);
                ctx.beginPath();
                ctx.moveTo(x1, padding);
                ctx.lineTo(x1, canvas.height - padding);
                ctx.stroke();
                
                // Limite destro
                const x2 = timeToScreen(lastTime);
                ctx.beginPath();
                ctx.moveTo(x2, padding);
                ctx.lineTo(x2, canvas.height - padding);
                ctx.stroke();
                
                ctx.restore();
            }
        }

        function calculateValue(hexString) {
            let value = parseInt(hexString, 16);
            if (value & 0x800000) value -= 0x1000000;
            return value;
        }
//-------------------------------------------------------------------------------------------------------------
        function drawPlotInc() {
            // Cancella l'animazione precedente se esiste
            if (animationFrameId && currBatchIndex > 2) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                //console.log("Animazione precedente cancellata.");
            }

            // Verifica buffer vuoto
            if (batchBuffer.length === 0) {
                //console.log("Buffer vuoto, nessun dato da disegnare.");
                return;
            }

            function draw(timestamp, index) {
                // Salva lo stato iniziale del contesto grafico
                //ctx.save();

                //ctx.beginPath();
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;

                const batch = batchBuffer[index];
              
                // Test dei range
                const timeInRange = batch && (parseInt(batch.t, 16) >= xScale.min && parseInt(batch.t, 16) <= xScale.max);
                //console.log(`Batch ${index} - Time range: ${timeInRange} (${batch.t})`);

                if (timeInRange) {
                    let value = parseInt(batch.v[0], 16);
                    if (value & 0x800000) value -= 0x1000000;
                   
				    updateYScale([value]);
                    //console.log("value: "+value);
                    // Calcola coordinate
                    //const x = timeToScreen(batch.t);

                    const x = timeToScreen(parseInt(batch.t, 16));
                    //const y = valueToScreen(value);

                    //const x = timeToScreen(xScale.min + index*5000);
                    const y = valueToScreen(value);
                    //console.log(`Coordinate: x=${x}, y=${y}, minx=${xScale.min}, maxx==${xScale.max}`);
                    //console.log(`Coordinate: x=${x}, y=${batch.first}`);
                    // Test coordinate nel plot
                    const inPlotArea = x >= padding && x <= canvas.width - padding &&
                                    y >= padding && y <= canvas.height - padding;
                    //console.log(`Coordinate in area plot: ${inPlotArea}`);

                    if (true) {
                        if (index === 0) {
                            // Reset e primo punto
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            drawGrid();
                            drawAxes();
                            ctx.beginPath();
                            ctx.moveTo(x, y);                            
                            console.log(`Reset e MoveTo: ${x},${y}`);
                        } else {
                            // Punti successivi
                            //ctx.moveTo(lastX, lastY);
                            ctx.lineTo(x, y);
                            //console.log(`LineTo: ${x},${y}`);
                        }
                        ctx.stroke();
                    }
                }

                // Ripristina lo stato iniziale del contesto grafico
                //ctx.restore();

                // Aggiorna l'ultimo punto
            }
            
            // Pianifica il prossimo frame se non in pausa
            if (!isPaused) {
                animationFrameId = requestAnimationFrame(((value) => (timestamp) => {
                                        draw(timestamp, value); // Cattura il valore corrente di `dynamicValue`
                                    })(currBatchIndex)); // Passa una copia al wrapper
                //console.log("Frame pianificato");
            }
        }
//--------------------------------------------------------------------------------------------------------------------------
        // Stampa di un batch
        function drawPlot() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            animationFrameId = requestAnimationFrame(() => {
                // Usa recordBuffer invece di batchBuffer
                if (recordBuffer.length === 0) return;

                const timeWindow = timebaseDiv * DIVISIONS_X * 1000000;
                
                // Clear e disegna griglia
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid();
                drawAxes();

                // Plot dei dati
                ctx.beginPath();
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;

                let isFirstPoint = true;
                let lastX = -1;
                let lastY = -1;
                let n = 1;

                //xScale.min = recordBuffer[0].t;
                // Prima trova i batch nella finestra temporale
                const batchesInWindow = recordBuffer.filter(batch => 
                    parseInt(batch.t, 16) >= xScale.min && parseInt(batch.t, 16) <= xScale.max
                );
                
                if(batchesInWindow.length < TARGET_POINTS){
                    n = Math.ceil((TARGET_POINTS - batchesInWindow.length) / batchesInWindow.length)+1;
                    n = Math.min(n, recordBuffer[0].v.length);
                }
                console.log("batchesInWindow.length: " + batchesInWindow.length);
                console.log("n: " + n);
                // Disegna tutti i punti nella finestra temporale corrente
                let count = 0;
                for (let batch of batchesInWindow) {
                    for(let j=0; j < n; j++){  
                        // filtra i campioni                      
                        //filterh.predict();
                        //value = filterh.update(calculateValue(batch.v[j]));
						value = calculateValue(batch.v[j]);
                        
                        // Calcola il timestamp preciso per questo campione nel batch
                        const sampleTime = parseInt(batch.t, 16) + (j * (1000000 / SAMPLE_RATE)); // in microsecondi
                
                        const x = Math.round(timeToScreen(sampleTime));
                        const y = Math.round(valueToScreen(value));

                        if (isFirstPoint) {
                            ctx.moveTo(x, y);
                            isFirstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                        
                        //lastX = x;
                        //lastY = y;
                        count++;
                    }
                }
                console.log("count: " + count);
                ctx.stroke();

                drawScrollLimits();
                drawThresholds(thresholds);

                /*
                // Aggiorna display
                document.getElementById('xRange').textContent = 
                    `${((xScale.max - xScale.min)/1000).toFixed(1)}ms`;
                document.getElementById('yRange').textContent = 
                    `${yScale.min.toFixed(0)} to ${yScale.max.toFixed(0)}`;
                    */
            });
        }
//--------------------------------------------------------------------------------------------------------------------------

        function drawGrid() {
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;           // Grid verticale ogni 5ms
            const timeStart = Math.floor(xScale.min / 5000) * 5000;
            for (let t = timeStart; t <= xScale.max; t += 5000) {
                const x = timeToScreen(t);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, canvas.height - padding);
                ctx.stroke();
            }

            // Grid orizzontale ogni 10% del range
            const valueStep = (yScale.max - yScale.min) / 10;
            for (let v = yScale.min; v <= yScale.max; v += valueStep) {
                const y = valueToScreen(v);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width - padding, y);
                ctx.stroke();
            }
        }

        function drawAxes() {
            ctx.beginPath();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();
        }                
        /*-------------------------------------------------------------------------
            CONTROL CALLBACKS SECTION 
          -------------------------------------------------------------------------
        */
       
        function updateTimebase() {
			const oldCenterTime = (xScale.max + xScale.min) / 2;
			timebaseDiv = parseFloat(document.getElementById('timebaseDiv').value);
			console.log("timebaseDiv update: " + timebaseDiv);
			
			const newTimeWindow = timebaseDiv * DIVISIONS_X * 1000000;
			xScale.min = oldCenterTime - newTimeWindow / 2;
			xScale.max = oldCenterTime + newTimeWindow / 2;
			
			console.log("Centro mantenuto a: " + oldCenterTime);
			console.log("Nuova finestra temporale: " + newTimeWindow);
			console.log("Nuovo range: " + xScale.min + " - " + xScale.max);
			
			if (!inputMode) {
				drawPlot();
			}
		}
        
        function updateSamplesPerBatch() {
            SAMPLE_RATE = parseInt(document.getElementById('sampleRate').value);
            samplesPerBatch = Math.floor(SAMPLE_RATE / EXPECTED_BATCH_RATE);
            document.getElementById('testSignalInfo').textContent = 
                `Samples per batch: ${samplesPerBatch} (${SAMPLE_RATE}Hz)`;
        }
       
        //function resizeCanvas() {
        //    canvas.width = canvas.offsetWidth;
        //    canvas.height = canvas.offsetHeight;
        //    //if (!isPaused) drawPlot();
        //}

        function toggleStreaming() {
            isStreaming = !isStreaming;
            
            if(isStreaming){
                inputMode = true;
            }else{
                inputMode = false;
            }

            updateConfig("streaming", isStreaming);

            if(isStreaming) {
                batchCount = 0;
                lastBatchTime = null;
                batchIntervals = [];
                batchBuffer = [];
                inputMode = true;
                resetView();
            }
        }

        function resetView() {
            updateSamplesPerBatch();
            batchBuffer.length = 0;
            currBatchIndex = 0;
			resetYScale();
            drawPlotInc();
        }

        function updateBufferSize() {
            bufferDurationSec = parseInt(document.getElementById('bufferDuration').value);
            bufferTimespan = bufferDurationSec * 1000000; // converti in microsecondi
            const avgInterval = batchIntervals.length > 0 ? 
                batchIntervals.reduce((a, b) => a + b, 0) / batchIntervals.length : 5;
            //maxBufferSize = Math.ceil((bufferDurationSec * 1000) / avgInterval);
            maxBufferSize = Math.ceil((bufferDurationSec * 1000) / 5);
            //trimBuffer();
            updateBufferInfo();
        }

        function updateBufferInfo() {
            document.getElementById('bufferInfo').textContent = 
                `${batchBuffer.length}/${maxBufferSize} batches`;
        }

        function trimBuffer() {
            if (batchBuffer.length > maxBufferSize) {
                batchBuffer = batchBuffer.slice(-maxBufferSize);
            }
        }

        function updateBatchStats() {
            if(batchIntervals.length > 0) {
                const avgInterval = batchIntervals.reduce((a, b) => a + b, 0) / batchIntervals.length;
                const actualRate = 1000 / avgInterval;
                const lastBatch = batchBuffer[batchBuffer.length - 1];
                const lastBatchSize = lastBatch ? lastBatch.v.length : 0;

                document.getElementById('batchStats').innerHTML = 
                    `Received Batches: ${batchCount}<br>` +
                    `Avg Interval: ${avgInterval.toFixed(2)} ms<br>` +
                    `Actual Rate: ${actualRate.toFixed(1)} Hz<br>` +
                    `Last Batch Size: ${lastBatchSize} samples`;
            }
        }

        function getDefaultFileName() {
            const now = new Date();
            const prefix = document.getElementById('filePrefix').value;
            return `${prefix}_${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${
                now.getDate().toString().padStart(2,'0')}_${
                now.getHours().toString().padStart(2,'0')}${
                now.getMinutes().toString().padStart(2,'0')}${
                now.getSeconds().toString().padStart(2,'0')}.txt`;
        }

        /*-------------------------------------------------------------------------
            POINT TO SCREEN CONVERSIONS SECTION
          -------------------------------------------------------------------------
        */        
        function timeToScreen(t) {
            return padding + (t - xScale.min) * (canvas.width - 2 * padding) / (xScale.max - xScale.min);
        }

        function valueToScreen(v) {
            return canvas.height - padding - (v - yScale.min) * (canvas.height - 2 * padding) / (yScale.max - yScale.min);
        }

        function screenToTime(x) {
            return xScale.min + (x - padding) * (xScale.max - xScale.min) / (canvas.width - 2 * padding);
        }

        function screenToValue(y) {
            return yScale.min + (canvas.height - padding - y) * (yScale.max - yScale.min) / (canvas.height - 2 * padding);
        }

        document.getElementById('sampleRate').addEventListener('change', function() {
            updateSamplesPerBatch();
            updateConfig('samplerate', this.value);
        });
        /*-------------------------------------------------------------------------
            TEST SIGNAL GENERATION SECTION
          -------------------------------------------------------------------------
        */
        
        /*
        //const initialTime = 1655484153000000; // Timestamp base
        const initialTime = Date.now();
        let count = 1000;
        async function generateTestSignal1() {
            const baseAmplitude = parseFloat(document.getElementById('testAmplitude').value);
            // Timestamp base: 1655484153000000 (62ad7af907880 in hex)
            const batches = [
            // 8 batch iniziali statici
            ...Array(count).fill().map((_, i) => ({
                t: (initialTime + i * 5000),
                v: Array(150).fill().map(() => {
                    const val = Math.floor(baseAmplitude + (Math.random() - 0.5) * 200);
                    return val.toString(16).padStart(6, '0');
                })
            })),
            // Le 5 fasi del salto come prima
            {
                t: (initialTime + count++ * 5000), // Statico pre-stacco
                v: Array(150).fill().map(() => {
                    const val = Math.floor(baseAmplitude + (Math.random() - 0.5) * 200);
                    return val.toString(16).padStart(6, '0');
                })
            },
            {
                t: (initialTime + count++ * 5000), // Stacco
                v: Array(150).fill().map((_, i) => {
                    const progress = i/150;
                    const val = Math.floor(baseAmplitude * (1 + 0.4 * Math.sin(Math.PI * progress)) + (Math.random() - 0.5) * 200);
                    return val.toString(16).padStart(6, '0');
                })
            },
            {
                t: (initialTime + count++ * 5000), // Volo
                v: Array(150).fill().map(() => {
                    const val = Math.floor(Math.random() * 400 - 200);
                    return val.toString(16).padStart(6, '0');
                })
            },
            {
                t: (initialTime + count++ * 5000), // Atterraggio
                v: Array(150).fill().map((_, i) => {
                    const progress = i/150;
                    const val = Math.floor(baseAmplitude * (1.8 * Math.exp(-progress * 5) + 1) + (Math.random() - 0.5) * 200);
                    return val.toString(16).padStart(6, '0');
                })
            },
            {
                t: (initialTime + count++ * 5000), // Ritorno statico
                v: Array(150).fill().map(() => {
                    const val = Math.floor(baseAmplitude + (Math.random() - 0.5) * 200);
                    return val.toString(16).padStart(6, '0');
                })
            }
            ];

            console.log("count: "+count);
            //console.log(JSON.stringify(batches));

            for (batch of batches) {
                processBatch(batch);
                //console.log(JSON.stringify(batch));
                await delay(5);
            }
        }*/        
        
        function generateTestSignal1() {
			const baseAmplitude = parseFloat(document.getElementById('testAmplitude').value);
			const batchSize = Math.floor(SAMPLE_RATE / EXPECTED_BATCH_RATE);
			const samples = [];
			
			const offset = 8; // 40ms = 8 batch da 5ms

			// genero tutti i campioni del batch immediatamente
			for (let i = 0; i < batchSize; i++) {
				// Ricalcola batchProgress e batchPhase per ogni campione
				const batchProgress = Math.floor(testSignalTime / 0.005);
				const batchPhase = (testSignalTime % 0.005) / 0.005;
				
				let value;
				
				if (batchProgress < offset) {
					value = baseAmplitude;
				} else if (batchProgress < 6 + offset) {
					value = baseAmplitude;
				} else if (batchProgress < 12 + offset) {
					const t = (batchProgress - (6 + offset) + batchPhase) / 6;
					value = baseAmplitude * (1 - 0.3 * Math.sin(Math.PI * t));
				} else if (batchProgress < 16 + offset) {
					const t = (batchProgress - (12 + offset) + batchPhase) / 4;
					value = baseAmplitude * (1 + Math.sin(Math.PI * t));
				} else if (batchProgress < 24 + offset) {
					value = 0;
				} else if (batchProgress < 28 + offset) {
					const t = (batchProgress - (24 + offset) + batchPhase) / 4;
					value = baseAmplitude * 2.5 * Math.exp(-t * 2);
				} else if (batchProgress < 36 + offset) {
					const t = (batchProgress - (28 + offset) + batchPhase) / 8;
					value = baseAmplitude * (1 + 0.4 * Math.exp(-t * 3) * Math.cos(2 * Math.PI * t));
				} else {
					testSignalTime = 0;
					return;
				}
				
				if(value > 8388607) value = 8388607;
				value = Math.round(value); // Arrotonda il valore
				value = value & 0xFFFFFF;  // Tronca a 24 bit
				if (value < 0) {
					value += 0x1000000;
				}
				
				let sample = value.toString(16).padStart(6, '0');
				samples.push(sample);
				
				testSignalTime += 1 / SAMPLE_RATE;
			}
			
			const batch = {
				t: Date.now() * 1000,
				v: samples
			};
			
			processBatch(batch);
			
			if (testSignalEnabled1) {
				timers[1] = setTimeout(generateTestSignal1, 1000 / EXPECTED_BATCH_RATE);
			} else {
				clearTimeout(timers[1]);
			}
		}

        function generateTestSignal0() {
            /*
            const currentTime = Date.now();
            if (lastTestSignalUpdate && currentTime - lastTestSignalUpdate < 5) {
                return; // Limit update rate
            }
            lastTestSignalUpdate = currentTime;
            */

            const frequency = parseFloat(document.getElementById('testFrequency').value);
            const baseAmplitude = parseFloat(document.getElementById('testAmplitude').value);
            //const amFrequency = parseFloat(document.getElementById('amFrequency').value);
            
            // Generate a batch of samples
            const batchSize = Math.floor(SAMPLE_RATE / EXPECTED_BATCH_RATE);
            const samples = [];
            
            // genero tutti i campioni del batch immediatamente
            for (let i = 0; i < batchSize; i++) {
                // Calculate amplitude modulation
                //const amplitude = baseAmplitude * (2 + Math.sin(2 * Math.PI * amFrequency * testSignalTime));
                
                // Generate sine wave sample
                let value = Math.round(baseAmplitude * Math.sin(2 * Math.PI * frequency * testSignalTime) + baseAmplitude);

                if(value > 8388607) value = 8388607;

                value = value & 0xFFFFFF;  // Tronca a 24 bit
                if (value < 0) {
                    value += 0x1000000;
                }               
                let sample = value.toString(16).padStart(6, '0');  // Converti in stringa hex di 6 caratteri
               
                // on batch sample queing
                samples.push(sample);
                
                testSignalTime += 1 / SAMPLE_RATE;
            }
            
            // Create batch object
            const batch = {
                t: Date.now() * 1000, // microseconds
                v: samples
            };
            
            // Process batch as if received from WebSocket
            processBatch(batch);
            
            // Schedule next batch if still enabled
            if (testSignalEnabled0) {
                timers[0] = setTimeout(generateTestSignal0, 1000 / EXPECTED_BATCH_RATE);
            }else{
                clearTimeout(timers[0]); 
            }
        }

    
        /*-------------------------------------------------------------------------
            WEBSOCKET CONTROL SECTION
          -------------------------------------------------------------------------
        */
        function onmessageEvent(event) {
            //if(!(adcSignalEnabled || remoteTestEnabled)) return;
            //console.log(`event.data: ${event.data}`);
            // All'arrivo di un batch
			// Evidenzia caratteri speciali
			//console.log('Con caratteri speciali visibili:', JSON.stringify(event.data));
            let batch = JSON.parse(event.data);
            //console.log("first: "+batch.first);
			//console.log("p");
			//counter++;
			if(counter == 100) {
				console.log("counter: "+counter);
                counter = 0;
            }
			if(Object.hasOwn(batch, 'bps')){
				console.log("bps: "+batch.bps);
				return;
			}
            processBatch(batch);
        }

        function processBatch(batch) {   
            if(!inputMode) return; 
			const timestamp = parseInt(batch.t, 16);
            // Aggiungilo al buffer
            batchBuffer.push(batch);
            //console.log("v: "+batch.v);
            // Buffer circolare per registrazione
            if (isRecording) {
                recordBuffer.push(batch);
                if (recordBuffer.length > recordBufferSize) {
                    recordBuffer.shift(); // Buffer circolare
                    console.log("Record buffer full, dropping oldest samples");
                }
            }
    
            // Aggiorna statistiche
            if(lastBatchTime !== null) {
                const interval = (timestamp - lastBatchTime) / 1000;
                batchIntervals.push(interval);
                if(batchIntervals.length > MAX_INTERVALS) {
                    batchIntervals.shift();
                }
            }

            lastBatchTime = timestamp;
            batchCount++;

            // Aggiorna le statistiche a schermo
            if(batchCount % 10 === 0) {
                updateBatchStats();
                updateBufferInfo();
            }
			
            // Stampa a schermo
            if (currBatchIndex === 0) {
                // Inizializzazione finestra temporale
                const firstBatch = batchBuffer[0];
                xScale.min = parseInt(firstBatch.t, 16);
                xScale.max = xScale.min + bufferTimespan;
                console.log(`Finestra temporale: ${xScale.min} - ${xScale.max}`);
                drawPlotInc();
                currBatchIndex++;
            } else if (currBatchIndex < maxBufferSize - 1) {
                //console.log(`currBatchIndex: ${currBatchIndex}, t: ${batchBuffer[currBatchIndex].t}`);
                // Batch intermedi
                drawPlotInc();
                currBatchIndex++;
                //console.log(`Batch corrente: ${currBatchIndex}`);
            } else {
                // Ultimo batch e reset
                drawPlotInc();
                console.log("Reset indice batch");
                currBatchIndex = 0;
				batchBuffer.length = 0;
            }
        }

        function onControlEvent(event) {
            const status = JSON.parse(event.data);
            console.log("Received current status: " + event.data);
            if(status.type === 'status') {
                document.getElementById('currentConfig').innerHTML = 
                    `Sample Rate: ${status.samplerate} Hz<br>` +
                    `EMA Alpha: ${status.alfaema}<br>` +
                    `Streaming: ${status.streaming == "true" ? 'In corso' : 'Bloccato'}<br>`+
                    `ADC Input: ${status.mode == 0 ? 'Attivato' : 'Disattivato'}<br>` +
                    `Remote Test: ${status.mode == 1 ? 'Attivato' : 'Disattivato'}<br>` +
                    `ADC Tone: ${status.mode == 2 ? 'Attivato' : 'Disattivato'}<br>` +
                    `Test frequency: ${status.freq}`;
                
                document.getElementById('streamToggle').innerHTML = status.streaming == "true" ? 'Stop Streaming' : 'Start Streaming';   
                document.getElementById('sampleRate').value = status.samplerate;
                document.getElementById('emaAlpha').value = status.alfaema;
                document.getElementById('enableADCToneL').checked = (status.mode == 3);
                document.getElementById('enableADCToneH').checked = (status.mode == 2);
                document.getElementById('enableADCSignal').checked = (status.mode == 0);
                document.getElementById('testFrequency').value = status.freq;
				
				if(status.streaming == "false"){
					counter = 0;
				}					
				
                SAMPLE_RATE = status.samplerate;
                batchIntervals = [];
                batchBuffer = [];
                handleRadioChange(false);// feedback, non comando...
                resetView();
            }else if(status.type == "event"){
                if (status.overflow > 0) {
                    overflowBox.classList.remove('green');
                    overflowBox.classList.add('red');
                } else {
                    overflowBox.classList.remove('red');
                    overflowBox.classList.add('green');
                }
            }else if('t' in status){
				console.log('Dati al posto di controllo: port swap');
				window.location.reload();
			}
        }
		
		var cntrAttempt = 0;
		var dataAttempt = 0;
		var maxAttempts = 3;

        // ✅ VERSIONE ULTRA-SEMPLIFICATA
		function connectWebSocket(ip, port, path, name, onMessageCallback) {
			let wsh = null;
			let reconnectAttempts = 0;
			let shouldReconnect = true;
			
			function init() {
				wsh = new WebSocket(`ws://${ip}:${port}/${path}`);
				
				wsh.onopen = () => {
					console.log(`✅ ${name} connesso - browser fa ping automatico`);
					reconnectAttempts = 0;
				};
				
				wsh.onclose = () => {
					console.log(`❌ ${name} disconnesso - ping automatico fallito`);
					
					if (shouldReconnect && reconnectAttempts < 10) {
						reconnectAttempts++;
						setTimeout(init, 1000 * reconnectAttempts);
					} else {
						window.location.reload(); // Ultimo resort
					}
				};
				
				wsh.onmessage = onMessageCallback; // ✅ Nessun ping applicativo!
				wsh.onerror = (e) => console.log(`💥 ${name} errore:`, e);
			}
			
			init();
			return wsh;
		}		
		
        function updateConfig(param, value) {
            if(wsControl && wsControl.readyState === WebSocket.OPEN) {
                const config = {};
                
                // Gestione dei diversi tipi di valore
                if (typeof value === 'string') {
                    // Converti in booleano se è "true" o "false"
                    if (value.toLowerCase() === 'true') {
                        config[param] = true;
                    } else if (value.toLowerCase() === 'false') {
                        config[param] = false;
                    } else {
                        // Prova a convertire in numero se non è un booleano
                        config[param] = isNaN(parseFloat(value)) ? value : parseFloat(value);
                    }
                } else {
                    // Mantieni il tipo originale per booleani e numeri
                    config[param] = value;
                }
                
                wsControl.send(JSON.stringify(config));
            } else {
                console.log('WebSocket not connected');
            }
        }

        //wsData = connectWebSocket("192.168.1.167", "81", "ws", "", onmessageEvent);
        //wsControl = connectWebSocket("192.168.1.167", "82", "ws", "", onControlEvent);

        //wsData = connectWebSocket("192.168.10.136", "81", "ws", "", onmessageEvent);
        //wsControl = connectWebSocket("192.168.10.136", "82", "ws", "", onControlEvent);

        //wsData = connectWebSocket("10.12.1.149", "81", "ws", "", onmessageEvent);
        //wsControl = connectWebSocket("10.12.1.149", "82", "ws", "", onControlEvent);

        // Ottiene l'hostname corrente dal browser
        const hostname = window.location.hostname;
        // Usa l'hostname per connettersi ai WebSocket
        wsData = connectWebSocket(hostname, "81", "ws", "", onmessageEvent);
        wsControl = connectWebSocket(hostname, "82", "ws", "", onControlEvent);

        const log = document.getElementById('log');
        const originalConsoleLog = console.log;
        console.log = function(...args) {
            originalConsoleLog.apply(console, args);
            const message = args.join(' ');
            log.innerHTML = message + '<br>' + log.innerHTML;
        };
			/*
			t1: start downward movement
			t2: max downward speed
			t3: max upward speed
			t4: take off
			t5: touch down
			*/
			
//------------------------------------------------JUMP DETECTION--------------------------------------------------------------------------------
		// =====================================================
		// SISTEMA COMPLETO: EMA MULTI-FASE + PULSANTE RICALCOLA
		// =====================================================

		// =====================================================
		// 1. CONTROLLI HTML EMA (come hai già)
		// =====================================================

		function addEMAControlsForJumpPhases() {
			const controlPanel = document.querySelector('.control-panel');
			
			const emaControlsDiv = document.createElement('div');
			emaControlsDiv.className = 'ema-jump-controls';
			emaControlsDiv.innerHTML = `
				<div style="margin: 10px 0; padding: 10px; background: #f0f8ff; border: 1px solid #0ea5e9; border-radius: 4px;">
					<label><strong>EMA per Fasi del Salto:</strong></label>
					
					<div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 10px; margin: 5px 0;">
						<div style="text-align: center;">
							<label style="font-size: 11px; color: #059669; font-weight: bold;">T1: Peso Statico</label>
							<select id="emaAlphaStatic" style="width: 100%;">
								<option value="0.01">0.01</option>
								<option value="0.02">0.02</option>
								<option value="0.05" selected>0.05</option>
								<option value="0.1">0.10</option>
								<option value="0.2">0.20</option>
							</select>
						</div>
						
						<div style="text-align: center;">
							<label style="font-size: 11px; color: #dc2626; font-weight: bold;">T1: Movimento</label>
							<select id="emaAlphaT1" style="width: 100%;">
								<option value="0.05">0.05</option>
								<option value="0.1" selected>0.10</option>
								<option value="0.2">0.20</option>
								<option value="0.3">0.30</option>
								<option value="0.5">0.50</option>
							</select>
						</div>
						
						<div style="text-align: center;">
							<label style="font-size: 11px; color: #0369a1; font-weight: bold;">T2-T3: Transizioni</label>
							<select id="emaAlphaT2T3" style="width: 100%;">
								<option value="0.05">0.05</option>
								<option value="0.1">0.10</option>
								<option value="0.2" selected>0.20</option>
								<option value="0.3">0.30</option>
								<option value="0.5">0.50</option>
							</select>
						</div>
						
						<div style="text-align: center;">
							<label style="font-size: 11px; color: #7c3aed; font-weight: bold;">T4: Stacco</label>
							<select id="emaAlphaT4" style="width: 100%;">
								<option value="0.1">0.10</option>
								<option value="0.2">0.20</option>
								<option value="0.3" selected>0.30</option>
								<option value="0.4">0.40</option>
								<option value="0.5">0.50</option>
							</select>
						</div>
						
						<div style="text-align: center;">
							<label style="font-size: 11px; color: #ea580c; font-weight: bold;">T5: Atterraggio</label>
							<select id="emaAlphaT5" style="width: 100%;">
								<option value="0.2">0.20</option>
								<option value="0.3">0.30</option>
								<option value="0.4" selected>0.40</option>
								<option value="0.5">0.50</option>
								<option value="0.7">0.70</option>
							</select>
						</div>
						
						<!-- ✅ NUOVO: Controllo EMA Derivata -->
						<div style="text-align: center;">
							<label style="font-size: 11px; color: #92400e; font-weight: bold;">Derivata Smooth</label>
							<select id="emaAlphaDerivative" style="width: 100%;">
								<option value="0.0001" selected>0.0001</option>
								<option value="0.0005">0.0005</option>
								<option value="0.001">0.001</option>
								<option value="0.005">0.005</option>
								<option value="0.01">0.01</option>
								<option value="0.02">0.02</option>
								<option value="0.05">0.05</option>
								<option value="0.1">0.10</option>
							</select>
						</div>
					</div>
					
					<div style="margin: 5px 0; font-size: 12px; color: #0369a1;">
						💡 <strong>Consigli:</strong> 
						Derivata: più basso = più smooth (0.0001 ultra-smooth, 0.1 veloce)
					</div>
					
					<div style="margin: 5px 0;">
						<button onclick="resetEMAToDefaults()" style="background: #6b7280; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; margin-right: 5px;">Reset Default</button>
						<button onclick="setEMAForHighNoise()" style="background: #dc2626; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; margin-right: 5px;">Alto Rumore</button>
						<button onclick="setEMAForFastJumps()" style="background: #059669; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; margin-right: 5px;">Salti Veloci</button>
						
						<!-- ✅ PULSANTE RICALCOLA INTEGRATO -->
						<button id="recalcThresholdsBtn" onclick="recalculateThresholds()" style="background: #0ea5e9; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-weight: bold;">🔄 Ricalcola Soglie</button>
					</div>
				</div>
			`;
			
			controlPanel.appendChild(emaControlsDiv);
			console.log('✅ Controlli EMA multi-fase + derivata configurabile aggiunti');
		}

		// =====================================================
		// 2. FUNZIONI PRESET EMA (come hai già)
		// =====================================================

		function resetEMAToDefaults() {
			document.getElementById('emaAlphaStatic').value = '0.05';
			document.getElementById('emaAlphaT1').value = '0.1';
			document.getElementById('emaAlphaT2T3').value = '0.2';
			document.getElementById('emaAlphaT4').value = '0.3';
			document.getElementById('emaAlphaT5').value = '0.4';
			document.getElementById('emaAlphaDerivative').value = '0.0001'; // ✅ Default derivata
			console.log('🔄 EMA reset ai valori di default (derivata=0.0001)');
		}

		function setEMAForHighNoise() {
			document.getElementById('emaAlphaStatic').value = '0.01';
			document.getElementById('emaAlphaT1').value = '0.05';
			document.getElementById('emaAlphaT2T3').value = '0.1';
			document.getElementById('emaAlphaT4').value = '0.2';
			document.getElementById('emaAlphaT5').value = '0.3';
			document.getElementById('emaAlphaDerivative').value = '0.0001'; // ✅ Ultra-smooth per rumore alto
			console.log('🔇 EMA configurato per alto rumore (derivata ultra-smooth)');
		}

		function setEMAForFastJumps() {
			document.getElementById('emaAlphaStatic').value = '0.05';
			document.getElementById('emaAlphaT1').value = '0.2';
			document.getElementById('emaAlphaT2T3').value = '0.3';
			document.getElementById('emaAlphaT4').value = '0.5';
			document.getElementById('emaAlphaT5').value = '0.7';
			document.getElementById('emaAlphaDerivative').value = '0.01'; // ✅ Più veloce per salti rapidi
			console.log('⚡ EMA configurato per salti veloci (derivata più reattiva)');
		}

		// =====================================================
		// 3. FUNZIONE RICALCOLA SOGLIE (NUOVA)
		// =====================================================

		function recalculateThresholds() {
			const btn = document.getElementById('recalcThresholdsBtn');
			
			// Controlla se ci sono dati
			if(!recordBuffer || recordBuffer.length === 0) {
				alert('⚠️ Carica prima un file con i dati del salto!');
				return;
			}
			
			// Feedback visivo
			const originalText = btn.innerHTML;
			btn.innerHTML = '⏳ Ricalcolo...';
			btn.disabled = true;
			btn.style.background = '#f59e0b';
			
			try {
				// Ricalcola le soglie con i valori EMA correnti
				console.log('🔄 Ricalcolo soglie con EMA correnti...');
				const result = detectJumpThresholds(recordBuffer, SAMPLE_RATE);
				
				// Aggiorna le soglie globali
				thresholds = result;
				
				// Ridisegna il grafico se siamo in modalità playback
				if(!inputMode && recordBuffer.length > 0) {
					drawPlot();
				}
				
				// Conta eventi trovati
				const eventsFound = [result.t1, result.t2, result.t3, result.t4, result.t5].filter(t => t !== null).length;
				
				// Feedback successo
				btn.innerHTML = `✅ ${eventsFound}/5`;
				btn.style.background = eventsFound === 5 ? '#059669' : '#f59e0b';
				
				console.log(`✅ Ricalcolo completato: ${eventsFound}/5 eventi trovati`);
				
				// Ripristina pulsante dopo 2 secondi
				setTimeout(() => {
					btn.innerHTML = originalText;
					btn.style.background = '#0ea5e9';
					btn.disabled = false;
				}, 2000);
				
			} catch(error) {
				console.error('❌ Errore durante il ricalcolo:', error);
				
				// Feedback errore
				btn.innerHTML = '❌ Errore';
				btn.style.background = '#dc2626';
				
				setTimeout(() => {
					btn.innerHTML = originalText;
					btn.style.background = '#0ea5e9';
					btn.disabled = false;
				}, 2000);
			}
		}

		// =====================================================
		// 4. ALGORITMO DETECTJUMPTHRESHOLDS (come hai già)
		// =====================================================

		function detectJumpThresholds(recordBuffer, sampleRate) {
			let result = {t1: null, t2: null, t3: null, t4: null, t5: null};
			let minDerivative = Infinity;
			let maxDerivative = -Infinity;
			let precBatchTime;
			let currBatchTime;
			let batchLen;
			let lastForce = null;
			
			// ✅ LEGGI TUTTI I VALORI EMA DAI MENU (INCLUSA DERIVATA)
			const emaAlphas = {
				static: parseFloat(document.getElementById('emaAlphaStatic')?.value || 0.05),
				t1: parseFloat(document.getElementById('emaAlphaT1')?.value || 0.1),
				t2t3: parseFloat(document.getElementById('emaAlphaT2T3')?.value || 0.2),
				t4: parseFloat(document.getElementById('emaAlphaT4')?.value || 0.3),
				t5: parseFloat(document.getElementById('emaAlphaT5')?.value || 0.4),
				// ✅ EMA DERIVATA CONFIGURABILE DAL MENU
				derivative: parseFloat(document.getElementById('emaAlphaDerivative')?.value || 0.0001)
			};
			
			console.log(`🎛️ EMA multi-fase: Statico=${emaAlphas.static}, T1=${emaAlphas.t1}, T2-T3=${emaAlphas.t2t3}, T4=${emaAlphas.t4}, T5=${emaAlphas.t5}, Derivata=${emaAlphas.derivative}`);
			
			// CALCOLO PESO STATICO (con EMA dedicato)
			let staticWeight = 0;
			let staticCount = 0;
			let staticEmaValue = null;
			
			for(let batchIdx = 0; batchIdx < recordBuffer.length && staticCount < 50; batchIdx++) {
				const batch = recordBuffer[batchIdx];
				
				for(let i = 0; i < batch.v.length && staticCount < 1000; i++) {
					const rawValue = calculateValue(batch.v[i]);
					
					if(staticEmaValue === null) {
						staticEmaValue = rawValue;
					} else {
						staticEmaValue = emaAlphas.static * rawValue + (1 - emaAlphas.static) * staticEmaValue;
					}
					
					staticWeight += staticEmaValue;
					staticCount++;
				}
			}
			staticWeight /= staticCount;
			
			console.log(`📊 Peso statico (EMA α=${emaAlphas.static}): ${staticWeight.toFixed(0)} da ${staticCount} campioni`);
			
			// INIZIALIZZAZIONE PRINCIPALE
			const dt0 = 1/sampleRate;
			precBatchTime = parseInt(recordBuffer[0].t, 16) / 1000000 - dt0;
			
			// EMA values separati per ogni fase
			let emaValues = {
				current: null,
				t1: null,      
				t2t3: null,
				t4: null,
				t5: null
			};
			
			// ✅ EMA per la derivata (configurabile)
			let derivativeEma = null;
			
			// Inizializza tutti gli EMA con il primo valore
			const firstRawValue = calculateValue(recordBuffer[0].v[0]);
			emaValues.t1 = firstRawValue;
			emaValues.t2t3 = firstRawValue;
			emaValues.t4 = firstRawValue;
			emaValues.t5 = firstRawValue;
			emaValues.current = firstRawValue;
			
			filterh.predict();
			lastForce = filterh.update(emaValues.current);
			batchLen = recordBuffer[0].v.length;
			
			// ANALISI PRINCIPALE CON EMA DINAMICO PER FASE
			let lastDerivative = null;
			let sampleIndex = 0;
			
			for(let batchIdx = 0; batchIdx < recordBuffer.length; batchIdx++) {
				const batch = recordBuffer[batchIdx];
				
				currBatchTime = parseInt(recordBuffer[batchIdx].t, 16) / 1000000;
				const dt = (currBatchTime - precBatchTime) / batchLen;
				
				for(let i = 0; i < batch.v.length; i++) {
					if(batchIdx === 0 && i === 0) {
						sampleIndex++;
						continue;
					}
					
					const rawValue = calculateValue(batch.v[i]);
					
					// AGGIORNA TUTTI GLI EMA CONTEMPORANEAMENTE
					emaValues.t1 = emaAlphas.t1 * rawValue + (1 - emaAlphas.t1) * emaValues.t1;
					emaValues.t2t3 = emaAlphas.t2t3 * rawValue + (1 - emaAlphas.t2t3) * emaValues.t2t3;
					emaValues.t4 = emaAlphas.t4 * rawValue + (1 - emaAlphas.t4) * emaValues.t4;
					emaValues.t5 = emaAlphas.t5 * rawValue + (1 - emaAlphas.t5) * emaValues.t5;
					
					// SELEZIONE EMA IN BASE ALLA FASE CORRENTE
					let selectedEmaValue;
					if(result.t1 === null) {
						selectedEmaValue = emaValues.t1;        // Fase T1: rilevamento movimento
					} else if(result.t2 === null || result.t3 === null) {
						selectedEmaValue = emaValues.t2t3;      // Fase T2-T3: transizioni peso
					} else if(result.t4 === null) {
						selectedEmaValue = emaValues.t4;        // Fase T4: stacco
					} else if(result.t5 === null) {
						selectedEmaValue = emaValues.t5;        // Fase T5: atterraggio
					} else {
						selectedEmaValue = emaValues.t2t3;      // Default: transizioni
					}
					
					filterh.predict();
					let force = filterh.update(selectedEmaValue);
					
					const currentTime = currBatchTime + (i * dt);
					
					// ✅ CALCOLA DERIVATA RAW
					const rawDerivative = (force - lastForce) / dt;
					
					// ✅ APPLICA EMA CONFIGURABILE ALLA DERIVATA
					let smoothedDerivative;
					if(derivativeEma === null) {
						derivativeEma = rawDerivative;  // Inizializza con la prima derivata
						smoothedDerivative = rawDerivative;
					} else {
						derivativeEma = emaAlphas.derivative * rawDerivative + (1 - emaAlphas.derivative) * derivativeEma;
						smoothedDerivative = derivativeEma;
					}
					
					// ✅ DEBUG: Confronto derivata raw vs smoothed (ogni 2000 campioni)
					if(sampleIndex % 2000 === 0) {
						console.log(`📈 Derivata #${sampleIndex}: Raw=${rawDerivative.toFixed(0)}, Smoothed=${smoothedDerivative.toFixed(2)}, Alpha=${emaAlphas.derivative}`);
					}
					
					/*
					t1: start downward movement
					t2: max downward speed
					t3: max upward speed
					t4: take off
					t5: touch down
					*/
					
					// ✅ USA DERIVATA SMOOTHED CONFIGURABILE NELLE SOGLIE
					
					//t1: start downward movement
					if(result.t1 === null && (smoothedDerivative < 0 && force < staticWeight && lastForce >= staticWeight)) {
						result.t1 = currentTime;
						console.log(`✅ T1 trovato (EMA α=${emaAlphas.t1}, derivata α=${emaAlphas.derivative}): time=${currentTime.toFixed(3)}, derivata_raw=${rawDerivative.toFixed(0)}, derivata_smooth=${smoothedDerivative.toFixed(2)}`);
					}
					
					//t2: max downward speed
					if(result.t2 == null && result.t1 !== null && smoothedDerivative > 0 && force > staticWeight && lastForce <= staticWeight) {
						result.t2 = currentTime;
						console.log(`✅ T2 trovato (derivata α=${emaAlphas.derivative}): time=${currentTime.toFixed(3)}, derivata_smooth=${smoothedDerivative.toFixed(2)}`);
					}
					
					// t3: max upward speed
					if(result.t3 == null && result.t2 !== null && smoothedDerivative < 0 && force < staticWeight && lastForce >= staticWeight) {
						result.t3 = currentTime;
						console.log(`✅ T3 trovato (derivata α=${emaAlphas.derivative}): time=${currentTime.toFixed(3)}, derivata_smooth=${smoothedDerivative.toFixed(2)}`);
					}
					
					// t4: take off
					if(result.t4 == null && force < 0.05 * staticWeight && smoothedDerivative < -100) {
						result.t4 = currentTime;
						console.log(`✅ T4 trovato (derivata α=${emaAlphas.derivative}): time=${currentTime.toFixed(3)}, derivata_smooth=${smoothedDerivative.toFixed(2)}`);
					}
					
					// t5: touch down
					if(result.t5 == null && result.t4 !== null && force > 0 * staticWeight && smoothedDerivative > 10) {
						result.t5 = currentTime;
						console.log(`✅ T5 trovato (derivata α=${emaAlphas.derivative}): time=${currentTime.toFixed(3)}, derivata_smooth=${smoothedDerivative.toFixed(2)}`);
					}
					
					lastForce = force;
					lastDerivative = smoothedDerivative;
					sampleIndex++;
				}
				precBatchTime = currBatchTime;
			}
			
			console.log(`t1: ${result.t1} - t2: ${result.t2} - t3: ${result.t3} - t4: ${result.t4} - t5: ${result.t5}`);
			console.log(`📊 Derivata finale smoothed (α=${emaAlphas.derivative}): ${derivativeEma?.toFixed(2)}`);
			return result;
		}		
    </script>
</body>
</html>
