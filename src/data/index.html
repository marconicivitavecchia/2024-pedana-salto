<!DOCTYPE html>
<html>
<head>
    <title>WebSocket Test</title>
    <style>
		.title {
			text-align: center;
			border: 1px solid rgba(255, 255, 255, 0.2);
			border-radius: 20px;
			padding: 20px 40px;
			text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
			letter-spacing: 1px;
			margin: 0;
		}
		.yscale-controls {
			margin: 5px 0;
			padding: 5px;
			background: #e8f4fd;
			border: 1px solid #0ea5e9;
			border-radius: 4px;
		}
		.yscale-info {
			font-size: 12px;
			color: #0369a1;
			font-weight: bold;
		}
        .limit-indicator {
            color: red;
            font-weight: bold;
            visibility: hidden;
        }
        .limit-indicator.active {
            visibility: visible;
        }
        #scrollLeft:disabled, #scrollRight:disabled {
            cursor: not-allowed;
        }
        .scope-controls {
            margin: 5px 0;
            padding: 5px;
            background: #f5f5f5;
            border: 1px solid #ddd;
        }
        .timebase-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 5px 0;
        }
        .control-panel {
            margin: 20px;
            padding: 10px;
            border: 1px solid #ccc;
        }
         /* NUOVO: Container flexbox per elementi affiancati */
        .flex-container {
            display: flex;
            gap: 20px; /* Spazio tra gli elementi */
            margin: 10px 0;
        }
        
        /* NUOVO: Stili per i singoli elementi flex */
        .flex-item {
            flex: 1; /* Ogni elemento occupa lo stesso spazio */
            padding: 10px;
            background-color: #e0e0e0;
            border-radius: 5px;
        }
        
        /* Responsive: su schermi piccoli, torna in colonna */
        @media (max-width: 768px) {
            .flex-container {
                flex-direction: column;
            }
        }
        #log {
            margin-top: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            height: 200px;
            overflow-y: auto;
        }
        .stats {
            margin: 10px 0;
            padding: 10px;
            background-color: #e0e0e0;
        }
        .plot-container {
            position: relative;
            margin: 10px 0;
        }
        #plotCanvas {
            width: 100%;
            height: 400px;  /* ridotto da 600px a 400px per comprimere verticalmente */
            border: 1px solid #ccc;
        }
        .plot-controls {
            margin: 5px 0;
            padding: 5px;
            background: #f5f5f5;
            border: 1px solid #ddd;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .buffer-controls {
            margin: 5px 0;
            padding: 5px;
            background: #f5f5f5;
            border: 1px solid #ddd;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .zoom-box {
            position: absolute;
            border: 1px dashed blue;
            background: rgba(0, 0, 255, 0.1);
            pointer-events: none;
            display: none;
        }
        .value-info {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            padding: 5px;
            display: none;
            pointer-events: none;
        }
        #fileInput {
            display: none;
        }
        .test-signal-controls {
            margin: 5px 0;
            padding: 5px;
            background: #f5f5f5;
            border: 1px solid #ddd;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .green {
            background-color: #22c55e;
        }

        .red {
            background-color: #ef4444;
        }
        .overflow-box {
            #width: 150px;
            padding: 5px;
            text-align: center;
            border-radius: 8px;
            font-weight: bold;
            color: white;
            transition: background-color 0.3s;
            mask-origin: 5px;
        }
		
		.cursor-line {
			position: absolute;
			top: 0;
			bottom: 0;
			width: 2px;
			pointer-events: none;
			z-index: 10;
		}

		.cursor-1 {
			background: #dc2626;
			box-shadow: 2px 0 4px rgba(220, 38, 38, 0.3);
		}

		.cursor-2 {
			background: #059669;
			box-shadow: 2px 0 4px rgba(5, 150, 105, 0.3);
		}

		.cursor-label {
			position: absolute;
			top: -25px;
			left: -15px;
			background: rgba(0,0,0,0.8);
			color: white;
			padding: 2px 6px;
			border-radius: 3px;
			font-size: 11px;
			font-weight: bold;
		}

		.measurement-panel {
			background: #e0f2fe;
			border: 2px solid #0ea5e9;
			border-radius: 8px;
			padding: 15px;
			margin: 15px 0;
		}

		.measurement-grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
			gap: 15px;
		}

		.measurement-item {
			background: white;
			padding: 10px;
			border-radius: 6px;
			border-left: 4px solid #0ea5e9;
		}

		.measurement-value {
			font-size: 16px;
			font-weight: bold;
			color: #111827;
		}
		/* NUOVO: Stili per il cursore trascinabile */
		/* NUOVO: Cursore in basso */
		.draggable-cursor {
			position: absolute;
			bottom: 0;
			width: 12px;        /* Ridotto da 20px */
			height: 15px;       /* Ridotto da 20px */
			cursor: ew-resize;
			z-index: 15;
			box-shadow: 0 -2px 8px rgba(245, 158, 11, 0.6);
			border-radius: 6px 6px 0 0;  /* Ridotto */
			border: 1px solid #fff;      /* Ridotto da 2px */
			transform: translateX(-50%); /* Centrato */
			margin-left: 0;              /* Rimuovi margini */
		}
		
		/* Aggiungi stili specifici per entrambi i cursori */
		#draggableCursor1 {
			background: linear-gradient(135deg, #f59e0b, #d97706);
			box-shadow: 0 -2px 8px rgba(245, 158, 11, 0.6);
		}

		#draggableCursor2 {
			background: linear-gradient(135deg, #10b981, #059669); /* Senza !important */
			box-shadow: 0 -2px 8px rgba(16, 185, 129, 0.6);
		}
		
		.draggable-cursor:hover {
			transform: translateX(-50%) scale(1.2);
			transition: all 0.2s ease;
		}

		/* Hover specifici */
		#draggableCursor1:hover {
			background: linear-gradient(135deg, #fbbf24, #f59e0b);
		}

		#draggableCursor2:hover {
			background: linear-gradient(135deg, #34d399, #10b981);
		}

		.draggable-cursor::before {
			position: absolute;
			top: 2px;           /* Aggiustato */
			left: 50%;
			transform: translateX(-50%);
			color: white;
			font-size: 6px;     /* Ridotto */
		}
		
		#draggableCursor1::before {
			content: '1';
			font-weight: bold;
		}

		#draggableCursor2::before {
			content: '2';
			font-weight: bold;
		}	

		/* Su schermi piccoli, posiziona i pannelli verticalmente */
		@media (max-width: 768px) {
			.cursor-info-panel-1 {
				top: 10px;
				right: 10px;
			}
			
			.cursor-info-panel-2 {
				top: 200px; /* Sotto il primo pannello */
				right: 10px;
			}
		}

		/* Pannello base (mantieni quello esistente) */
		.cursor-info-panel {
			position: absolute;
			background: rgba(0, 0, 0, 0.85);
			color: white;
			padding: 10px 15px;
			border-radius: 8px;
			font-family: monospace;
			font-size: 12px;
			box-shadow: 0 4px 12px rgba(0,0,0,0.3);
			min-width: 250px;
			z-index: 20;
			display: none;
		}

		/* Posizionamento specifico per ogni pannello */
		.cursor-info-panel-1 {
			top: -145px;
			right: 290px;
			border-left: 4px solid #f59e0b; /* Bordo arancione */
		}

		.cursor-info-panel-2 {
			top: -145px;
			right: 10px; /* Spostato a sinistra per non sovrapporsi */
			border-left: 4px solid #10b981; /* Bordo verde */
		}

		/* Titolo del cursore */
		.cursor-title {
			font-weight: bold;
			margin-bottom: 8px;
			text-align: center;
			padding-bottom: 5px;
			border-bottom: 1px solid rgba(255,255,255,0.3);
		}

		/* Stili esistenti per info-row, info-label, info-value rimangono uguali */
		.cursor-info-panel .info-row {
			display: flex;
			justify-content: space-between;
			margin: 3px 0;
			padding: 2px 0;
			border-bottom: 1px solid rgba(255,255,255,0.2);
		}

		.cursor-info-panel .info-label {
			color: #fbbf24;
			font-weight: bold;
		}

		.cursor-info-panel .info-value {
			color: #34d399;
			text-align: right;
		}
    </style>
</head>
<body>
    <h1 class="title">Websocket data analysis</h1>

    <div class="control-panel">
        <div class="config-item">
            <label for="sampleRate">Sample Rate:</label>
            <select id="sampleRate" onchange="updateConfig('samplerate', this.value)">
                <option value="200">200 sps</option>
                <option value="600">600 sps</option>
                <option value="1000">1000 sps</option>
				<option value="2000">2000 sps</option>
				<option value="3000">3000 sps</option>
				<option value="6000">6000 sps</option>
                <option value="10000">10 Ksps</option>
                <option value="15000">15 Ksps</option>
                <option value="30000" selected>30 kHz</option>
            </select>
        </div>

        <div class="config-item">
            <label for="emaAlpha">EMA Alpha:</label>
            <select id="emaAlpha" onchange="updateConfig('alfaema', this.value)">
				<option value="0.005">0.005</option>
				<option value="0.01">0.01</option>
				<option value="0.02">0.02</option>
				<option value="0.03">0.03</option>
				<option value="0.04">0.04</option>
                <option value="0.05">0.05</option>
				<option value="0.06">0.06</option>
				<option value="0.07">0.07</option>
				<option value="0.08">0.08</option>
				<option value="0.09">0.09</option>
                <option value="0.1">0.10</option>
                <option value="0.2">0.20</option>
                <option value="0.3">0.30</option>
				<option value="0.4">0.40</option>
                <option value="0.5">0.50</option>
				<option value="0.6">0.60</option>
				<option value="0.7">0.70</option>
				<option value="0.8">0.80</option>
				<option value="0.9">0.90</option>
				<option value="1" selected>1</option>
            </select>
        </div>
        <div class="buffer-controls">
            <label>Buffer Duration (s):
                <input type="number" id="bufferDuration" value="10" min="1" max="3600" 
                       onchange="updateBufferSize()">
            </label>
            <span>Buffer Size: <span id="bufferInfo">0/0</span></span>
        </div>       
        <div class="config-item">
            <label>Streaming Control:</label>
            <button id="streamToggle" onclick="toggleStreaming()">Start Streaming</button>
        </div>

        <!-- MODIFICATO: Wrapper flexbox per Current Configuration e Batch Stats -->
        <div class="flex-container">
            <div class="flex-item">
                <label><strong>Current Configuration:</strong></label>
                <div id="currentConfig">Waiting for connection...</div>
            </div>
            
            <div class="flex-item">
                <label><strong>Batch Stats:</strong></label>
                <div id="batchStats">No data yet</div>
            </div>
			 <div id="overflowBox" class="overflow-box green flex-item">
                OVERFLOW
            </div>
        </div>
        <div class="test-signal-controls">
            <label>Input selection:</label>
            <label>
                <input type="radio" id="enableADCSignal" name="testSignal">
                ADC real input
            </label>
            <label>
                <input type="radio" id="enableTestSignal0" name="testSignal">
                Local emulated sine wave
            </label>
            <label>
                <input type="radio" id="enableTestSignal1" name="testSignal">
                Local emulated jump
            </label>
            <label>
                <input type="radio" id="enableADCToneL" name="testSignal">
                ADC real tone Low
            </label>
            <label>
                <input type="radio" id="enableADCToneH" name="testSignal">
                ADC real tone High
            </label>
            <label>Sine wave params:</label>
            <label>Frequency (Hz):
                <input type="number" id="testFrequency" value="1" min="1" max="100" step="1" 
                       onchange="updateConfig('freq', this.value)">
            </label>
            <label>Base Amplitude:
                <input type="number" id="testAmplitude" value="4194304" min="1000" max="8388608">
            </label>
            <span id="testSignalInfo">Samples per batch: 0</span>
        </div>
        <!-- CORRETTO: -->
		<div class="filter-controls">
			<label>Recorded data filtering:</label>
			<label>
				<input type="radio" name="filter" value="none" checked>
				None
			</label>
			<label>
				<input type="radio" name="filter" value="kalman">
				Kalman
			</label>
		</div>
        <div class="scope-controls">
            <div class="timebase-controls">
                <label>Timebase (ms/div):
                    <select id="timebaseDiv" onchange="updateTimebase()">
                        <option value="0.005">0.005</option>
                        <option value="0.01">0.01</option>
                        <option value="0.02">0.02</option>
                        <option value="0.05">0.05</option>
                        <option value="0.1">0.1</option>
                        <option value="0.2">0.2</option>
                        <option value="0.5">0.5</option>
                        <option value="1" selected>1</option>
                        <option value="2">2</option>
                        <option value="5">5</option>
                        <option value="10">10</option>
                        <option value="20">20</option>
                        <option value="50">50</option>
                    </select>
                </label>
                <label>Play offset (ms):
                    <input type="number" id="startOffset" value="0" min="0" max="1000" step="1">
                </label>
                <button id="recordBtn" onclick="toggleRecording()">Start Recording</button>
                <button id="loadRecordBtn" onclick="document.getElementById('recordFileInput').click()">Load Record</button>
                <button id="play">></button>
                <button id="scrollLeft"><<</button>
                <button id="scrollRight">>></button>
                <button id="scrollLeftFast"><<<</button>
                <button id="scrollRightFast">>>></button>
				<button onclick="centerViewOnData()">Center on Data</button>
                <label>File Name Prefix:
                    <input type="text" id="filePrefix" value="data">
                </label>
				<input type="file" id="recordFileInput" accept=".txt,.json" style="display: none">
            </div>
            </div>
        </div>
    </div>

    <div class="plot-container">
        <div class="plot-controls">
            <button onclick="resetView()">Reset View</button>
            <!-- ✅ CONTROLLI CURSORI -->
            <button id="resetCursors" onclick="resetCursors()" disabled>Reset Cursori</button>
			<!-- NUOVO: Controllo cursore trascinabile -->
			<button id="toggleDraggableCursor" onclick="toggleDraggableCursor()">Attiva Cursore Trascinabile</button>
        </div>
        <canvas id="plotCanvas"></canvas>
        
		<!-- NUOVO: Cursore trascinabile -->
		<div id="draggableCursor1" class="draggable-cursor" style="display: none;"></div>
		<div id="draggableCursor2" class="draggable-cursor" style="display: none; background: linear-gradient(135deg, #10b981, #059669);"></div>
		<!-- Sostituisci il pannello singolo con due pannelli -->
		
		<!-- Pannello Cursore 1 (Arancione) -->
		<div id="cursorInfoPanel1" class="cursor-info-panel cursor-info-panel-1">
			<div class="cursor-title">🟠 Cursore 1</div>
			<div class="info-row">
				<span class="info-label">Tempo:</span>
				<span class="info-value" id="cursorTime1">-</span>
			</div>
			<div class="info-row">
				<span class="info-label">Batch:</span>
				<span class="info-value" id="cursorBatch1">-</span>
			</div>
			<div class="info-row">
				<span class="info-label">Indice Batch:</span>
				<span class="info-value" id="cursorSampleIndex1">-</span>
			</div>
			<div class="info-row">
				<span class="info-label">Valore:</span>
				<span class="info-value" id="cursorValue1">-</span>
			</div>
			<div class="info-row">
				<span class="info-label">Posizione X:</span>
				<span class="info-value" id="cursorPosition1">-</span>
			</div>
			<div class="info-row">
				<span class="info-label">Forza relativa:</span>
				<span class="info-value" id="relativeForce1">-</span>
			</div>
			<div class="info-row">
				<span class="info-label">sdRatio:</span>
				<span class="info-value" id="sdRatio1">-</span>
			</div>
		</div>

		<!-- Pannello Cursore 2 (Verde) -->
		<div id="cursorInfoPanel2" class="cursor-info-panel cursor-info-panel-2">
			<div class="cursor-title">🟢 Cursore 2</div>
			<div class="info-row">
				<span class="info-label">Tempo:</span>
				<span class="info-value" id="cursorTime2">-</span>
			</div>
			<div class="info-row">
				<span class="info-label">Batch:</span>
				<span class="info-value" id="cursorBatch2">-</span>
			</div>
			<div class="info-row">
				<span class="info-label">Indice Batch:</span>
				<span class="info-value" id="cursorSampleIndex2">-</span>
			</div>
			<div class="info-row">
				<span class="info-label">Valore:</span>
				<span class="info-value" id="cursorValue2">-</span>
			</div>
			<div class="info-row">
				<span class="info-label">Posizione X:</span>
				<span class="info-value" id="cursorPosition2">-</span>
			</div>
			<div class="info-row">
				<span class="info-label">Forza relativa:</span>
				<span class="info-value" id="relativeForce2">-</span>
			</div>
						<div class="info-row">
				<span class="info-label">sdRatio:</span>
				<span class="info-value" id="sdRatio2">-</span>
			</div>
		</div>
        
        <div class="zoom-box" id="zoomBox"></div>
        <div class="value-info" id="valueInfo"></div>
    </div>

    <!-- ✅ PANNELLO MISURAZIONI CURSORI -->
    <div id="measurementPanel" class="measurement-panel" style="display: none;">
        <div class="measurement-title">📊 Misurazioni tra Cursori</div>
        <div class="measurement-grid">
            <div class="measurement-item">
                <div class="measurement-label">Distanza Temporale</div>
                <div id="timeDiff" class="measurement-value">-</div>
            </div>
            <div class="measurement-item">
                <div class="measurement-label">Distanza in Batch</div>
                <div id="batchDiff" class="measurement-value">-</div>
            </div>
            <div class="measurement-item">
                <div class="measurement-label">Distanza in Campioni</div>
                <div id="sampleDiff" class="measurement-value">-</div>
            </div>
            <div class="measurement-item">
                <div class="measurement-label">Differenza Valori</div>
                <div id="valueDiff" class="measurement-value">-</div>
            </div>
			<div class="measurement-item">
                <div class="measurement-label">Altezza da velocità</div>
                <div id="hv" class="measurement-value">-</div>
            </div>
			<div class="measurement-item">
                <div class="measurement-label">Heel lift</div>
                <div id="hl" class="measurement-value">-</div>
            </div>
			<div class="measurement-item">
                <div class="measurement-label">Altezza combinata</div>
                <div id="ht" class="measurement-value">-</div>
            </div>
        </div>
    </div>
	
    <div id="log"></div>
	<div id="report"></div>

    <script src="matrixUtils.js"></script>
    <script src="filter.js"></script>       

    <script>
		var counter = 0;
        // Base configuration variables
        let SAMPLE_RATE = 30000;
        const EXPECTED_BATCH_RATE = 200;
        let wsData, wsControl;
        let isStreaming = false;
        let isPaused = false;
        let batchCount = 0;
        let lastBatchTime = null;
        let batchIntervals = [];
        let batchBuffer = [];
        // Test signal variables
        let testSignalTime = 0;
        let lastTestSignalUpdate = 0;
        let testSignalEnabled0 = false;
        let testSignalEnabled1 = false;
        let remoteTestEnabled = false;
        let adcSignalEnabled = false;
        let remoteTestTone = false;
        let inputMode = true;
        
        const MAX_INTERVALS = 200;
        let bufferDurationSec = 10;
        let bufferTimespan = bufferDurationSec * 1000000; // converti in microsecondi
        let maxBufferSize = Math.ceil((bufferDurationSec * 1000) / 5);
        let currBatchIndex = 0;
        let lastFrameTime = 0;
        let filterh = new Filter();
        let filtera = new Filter();

        // Variabili per registrazione
        let isRecording = false;
        let recordBuffer = [];
		let loadBuffer = [];
        let recordBufferSize = 50000; // Circa 250 secondi di dati con intervallo 5ms
        let currPlayIndex = 0;
		let thresholdsList = [];

        // Display configuration
        const MIN_PLOT_INTERVAL = 5;
        const MIN_PIXEL_DELTA = 2;
        const padding = 10;
        const TARGET_POINTS = 10000;

        // Oscilloscope specific variables
        // Variabili di stato per la vista
        let xScale = { min: 0, max: 100 };
        let yScale = { min: 0, max: 8388608 };
        let timebaseDiv = 5;      // ms per divisione
        const DIVISIONS_X = 10;   // divisioni orizzontali
        let viewOffset = 0;       // offset temporale per lo scroll
        let pausedAt = null;      // timestamp quando messo in pausa
        let animationFrameId = null;  // ID per cancelAnimationFrame
        let isAtLeftLimit = false;  // flag per limite sinistro
		// Variabili cursori (aggiungi dopo le tue variabili globali)
		let cursorMode = false;
		// NUOVO: Variabili per il cursore trascinabile
		let draggableCursorsActive = false;
		let isDragging = null; // Memorizza quale cursore si sta trascinando
		let cursors = {
			cursor1: { x: 0, time: 0, batchIndex: -1, sampleIndex: -1, value: 0, rf: 0, relArea: 0, hv: 0, hl: 0, ht: 0 },
			cursor2: { x: 0, time: 0, batchIndex: -1, sampleIndex: -1, value: 0, rf: 0, relArea: 0, hv: 0, hl: 0, ht: 0 }
		};
		let Fstatico1 = 0;
		let Fstatico2 = 0;
		let Fstatico = 0;
		let globalSDMean = 0;
		
		// Con queste:
		
		
        // Variabili di stato per zoom e pan
        //let isMouseDown = false;
        let startX = 0;
        let startY = 0;
        let timers = [];
		let autoScale = true; // Flag per abilitare/disabilitare auto-scaling
		let yScaleBuffer = []; // Buffer per valori recenti
		const Y_SCALE_BUFFER_SIZE = 500; // Numero di campioni da considerare per la scala
        // scroll management
        const delay = (msec) => new Promise(resolve => setTimeout(resolve, msec)) ;
        let isScrolling = false;
        let right = true;
        const leftButton = document.getElementById('scrollLeft');
        const rightButton = document.getElementById('scrollRight');
        const leftButtonFast = document.getElementById('scrollLeftFast');
        const rightButtonFast = document.getElementById('scrollRightFast');
        // Setup canvas
        const canvas = document.getElementById('plotCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        window.addEventListener('resize', resizeCanvas);
		window.addEventListener('load', () => {
			addMetadataControls();
			addEMAControlsForJumpPhases();
			updateSamplesPerBatch();
			addYScaleControls();
			setInterval(updateYScaleInfo, 1000);
			addSaveLoadControls(); // Aggiungi i nuovi controlli
			console.log('🎛️ Sistema EMA completo con pulsante ricalcola inizializzato');
		});
		// Variabile globale per il gain       

        leftButton.onmousedown = async () => {
            isScrolling = true;
            while (isScrolling) {
                scrollView(-timebaseDiv * 10000);
                await delay(200);
            }
        }
        rightButton.onmousedown = async () => {
            isScrolling = true;
            while (isScrolling) {
                scrollView(timebaseDiv * 10000);
                await delay(200);
            }
        }
        leftButtonFast.onmousedown = async () => {
            isScrolling = true;
            while (isScrolling) {
                scrollView(-timebaseDiv * 100000);
                await delay(200);
            }
        }
        rightButtonFast.onmousedown = async () => {
            isScrolling = true;
            while (isScrolling) {
                scrollView(timebaseDiv * 100000);
                await delay(200);
            }
        }
        leftButton.onmouseup = () => {
            isScrolling = false;
        }
        rightButton.onmouseup = () => {
            isScrolling = false;
        }
        leftButtonFast.onmouseup = () => {
            isScrolling = false;
        }
        rightButtonFast.onmouseup = () => {
            isScrolling = false;
        }
        
        const radioButtons = document.querySelectorAll('input[name="filter"]');
        radioButtons.forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (e.target.checked) {
                    console.log('Selected:', e.target.value);
                    if(e.target.value =="kalman"){
                        filterh = new JumpHeightKalmanFilter(1/SAMPLE_RATE);
                        filtera = new AccelerationKalmanFilter(1/SAMPLE_RATE);
                    }else{
                        filterh = new Filter();
                        filtera = new Filter();
                    }
                }
            });
        });

        // Seleziona tutti i radio button con lo stesso nome
        const radioButtons2 = document.querySelectorAll('input[name="testSignal"]');
        // Funzione per gestire checked/unchecked

        function handleRadioChange(send = true) {
            const radio1 = document.getElementById('enableADCSignal');
            const radio2 = document.getElementById('enableTestSignal0');
            const radio3 = document.getElementById('enableTestSignal1');
            const radio4 = document.getElementById('enableADCToneL');
            const radio5 = document.getElementById('enableADCToneH');

            if (radio1.checked) {
                console.log('Opzione adc input selezionata');
                inputMode = true;
                adcSignalEnabled = true;
                testSignalTime = 0;
                resetView();
                updateSamplesPerBatch();
                const batch = {
                    t: 0,
                    v: [0]
                };
                onmessageEvent({ data: JSON.stringify(batch) });
                if(send) updateConfig("mode", 0);
            } else {
                adcSignalEnabled = false;
                console.log('Opzione adc input deselezionata');
            }

            if (radio2.checked) {
                console.log('Opzione sine input selezionata');
                inputMode = true;
                testSignalEnabled0 = true;
                testSignalTime = 0;
                resetView();
                updateSamplesPerBatch();
                generateTestSignal0();
            } else {
                testSignalEnabled0 = false;
                console.log('Opzione sine input deselezionata');
            }

            if (radio3.checked) {
                console.log('Opzione simulated jump selezionata');                   
                inputMode = true;
                testSignalEnabled1 = true;
                testSignalTime = 0;
                resetView();
                updateSamplesPerBatch();
                generateTestSignal1();   
            } else {
                testSignalEnabled1 = false;
                console.log('Opzione simulated jump deselezionata');
            }

            if (radio4.checked) {
                console.log('Opzione enableADCToneL');
                remoteTestEnabled = true;
                inputMode = true;
                resetView();
                if(send) updateConfig("mode", 3);
                const batch = {
                    t: 0,
                    v: [0]
                };
                onmessageEvent({ data: JSON.stringify(batch) });
            } else {
                remoteTestEnabled = false;
                console.log('Opzione ADCToneL deselezionata');
            }

            if (radio5.checked) {
                console.log('Opzione tono enableADCToneH');
                remoteTestTone = true;
                adcSignalEnabled = true;
                inputMode = true;
                resetView();
                testSignalTime = 0;
                updateSamplesPerBatch();
                if(send) updateConfig("mode", 2);
                const batch = {
                    t: 0,
                    v: [0]
                };
                onmessageEvent({ data: JSON.stringify(batch) });
            } else {
                console.log('Opzione ADCToneH deselezionata');
            }
        }
        // Aggiungi il gestore dell'evento "change" a ogni radio button
        radioButtons2.forEach(radio => {
            radio.addEventListener('change', handleRadioChange);
        });
//----------------------------------------------------------------------------------------------------------------------- OGGI -----------------------------			
       //----------------------------------------------------------------------------------------------------------------------- OGGI -----------------------------			
        updateConfig('freq', 1);

        // =====================================================
        // VARIABILI GLOBALI PER IL SISTEMA DI GAIN
        // =====================================================

        // Fattore di zoom per l'asse Y (1.0 = normale, >1.0 = zoom in, <1.0 = zoom out)
        let yGain = 1.0;

        // Variabili globali per la gestione della pressione continua
        let buttonPressIntervals = {};
        let buttonPressTimeouts = {};

        // =====================================================
        // FUNZIONI PRINCIPALI DI CONTROLLO GAIN
        // =====================================================

        /**
         * Aggiusta il gain aggiungendo o sottraendo un valore (controllo additivo)
         * @param {number} delta - Valore da aggiungere/sottrarre (1, -1, 10, -10)
         */
        function adjustGainBy(delta) {
            // Se auto-scale è attivo, non fare nulla - i tasti funzionano solo in modalità manuale
            if (autoScale) {
                console.log('Gain manuale disabilitato durante auto-scale');
                return;
            }
            
            // Calcola il nuovo gain aggiungendo il delta
            const newGain = yGain + delta;
            
            // Protezione più rigorosa: limiti più stretti per evitare crash
            if (newGain < 0.5 || newGain > 256) {
                console.log(`Gain ${newGain.toFixed(1)}x fuori dai limiti sicuri (0.5x - 50x)`);
                return; // Esce senza applicare se fuori limiti
            }
            
            // USA il centro CORRENTE della vista (dove hai navigato con W/S)
            const currentCenter = (yScale.max + yScale.min) / 2;
            
            // PRIMA aggiorna il gain globale
            yGain = newGain;
            
            // Calcola il nuovo range usando SEMPRE il range standard come riferimento
            const standardRange = 8388608; // Range di riferimento standard
            const newRange = standardRange / yGain;
            
            // Applica il nuovo range mantenendo il centro CORRENTE (dove sei navigato)
            yScale.min = currentCenter - newRange / 2;
            yScale.max = currentCenter + newRange / 2;
            
            // Verifica finale dei valori
            if (isNaN(yScale.min) || isNaN(yScale.max) || !isFinite(yScale.min) || !isFinite(yScale.max)) {
                console.log('Valori finali non validi, reset completo');
                yScale.min = 0;
                yScale.max = 8388608;
                yGain = 1.0;
            }
            
            // Aggiorna tutti i display che mostrano il gain
            updateGainDisplay();        
            updateAutoScaleGainDisplay(); 
            
            // Ridisegna il grafico per mostrare le modifiche
            if (inputMode) {
                drawPlotInc(); 
            } else {
                drawPlot();    
            }
            
            console.log(`Y Gain aggiustato di ${delta}: nuovo gain ${yGain.toFixed(2)}x, range: ${(yScale.max - yScale.min).toFixed(0)}, centro: ${currentCenter.toFixed(0)}`);
        }

        /**
         * Aggiusta il centro della vista spostando su/giù
         * @param {number} delta - Valore da aggiungere/sottrarre al centro (±500000)
         */
        function adjustCenterBy(delta) {
            // Se auto-scale è attivo, non fare nulla - i tasti funzionano solo in modalità manuale
            if (autoScale) {
                console.log('Controllo centro disabilitato durante auto-scale');
                return;
            }
            
            // Calcola il centro corrente
            const currentCenter = (yScale.max + yScale.min) / 2;
            const newCenter = currentCenter + delta;
            
            // Calcola il range corrente (mantienilo uguale)
            const currentRange = yScale.max - yScale.min;
            
            // Applica il nuovo centro mantenendo lo stesso range
            yScale.min = newCenter - currentRange / 2;
            yScale.max = newCenter + currentRange / 2;
            
            // Verifica che i valori risultanti siano ragionevoli
            if (isNaN(yScale.min) || isNaN(yScale.max) || !isFinite(yScale.min) || !isFinite(yScale.max)) {
                console.log('Valori di centro non validi, ripristino');
                yScale.min = 0;
                yScale.max = 8388608;
            }
            
            // Ridisegna il grafico per mostrare le modifiche
            if (inputMode) {
                drawPlotInc(); 
            } else {
                drawPlot();    
            }
            
            console.log(`Centro spostato di ${delta}: nuovo centro ${newCenter.toFixed(0)}, range: ${currentRange.toFixed(0)}`);
        }

        /**
         * Resetta il gain a 1.0x (valore normale)
         */
        function resetGain() {
            // Riporta il gain ai valori di default
            yGain = 1.0;
            
            // Cancella il buffer auto-scale per ripartire pulito
            yScaleBuffer = [];
            
            // RESET SEMPLICE: usa sempre valori standard fissi
            yScale.min = 0;
            yScale.max = 8388608;
            
            // Aggiorna tutti i display
            updateGainDisplay();
            updateAutoScaleGainDisplay();
            
            // Ridisegna il grafico
            if (inputMode) {
                drawPlotInc();
            } else {
                drawPlot();
            }
            
            console.log('Y Gain e scala Y resettati ai valori standard (0 - 8388608)');
        }

        // =====================================================
        // FUNZIONI DI CALCOLO E APPLICAZIONE GAIN
        // =====================================================

        /**
         * Calcola il gain "effettivo" basato sulla scala Y corrente
         * Utile per sapere quanto zoom ha applicato l'auto-scale
         */
        function calculateEffectiveGain() {
            const defaultRange = 8388608; // Range Y di default (da 0 a 8388608)
            const currentRange = yScale.max - yScale.min; // Range corrente
            
            // Più piccolo è il range, maggiore è il gain (zoom)
            return defaultRange / currentRange;
        }

        /**
         * Applica il gain manualmente alla scala Y quando auto-scale è disattivo
         */
        function applyGainToYScale() {
            // Trova il centro della vista corrente
            const centerY = (yScale.max + yScale.min) / 2;
            
            // Calcola il range corrente
            const currentRange = yScale.max - yScale.min;
            
            // Calcola il nuovo range applicando il gain
            // Gain maggiore = range più piccolo = più zoom
            const newRange = currentRange / yGain;
            
            // Aggiorna i limiti mantenendo il centro
            yScale.min = centerY - newRange / 2;
            yScale.max = centerY + newRange / 2;
            
            console.log(`Scala Y con gain ${yGain}x: ${yScale.min.toFixed(0)} - ${yScale.max.toFixed(0)}`);
        }

        // =====================================================
        // FUNZIONI DI AGGIORNAMENTO DISPLAY
        // =====================================================

        /**
         * Aggiorna il display del gain totale ("Total Gain: 15.2x")
         */
        function updateGainDisplay() {
            const currentGainElement = document.getElementById('currentGain');
            
            if (currentGainElement) {
                // Mostra il gain corrente
                currentGainElement.textContent = `Total Gain: ${yGain.toFixed(2)}x`;
                
                // Cambia colore in base al livello di gain
                if (yGain > 5) {
                    currentGainElement.style.color = '#dc2626'; // Rosso per gain alto
                } else if (yGain > 1) {
                    currentGainElement.style.color = '#0369a1'; // Blu per gain medio
                } else {
                    currentGainElement.style.color = '#059669'; // Verde per gain basso/zoom out
                }
            }
        }

        /**
         * Aggiorna il display del gain effettivo quando auto-scale è attivo
         */
        function updateEffectiveGainDisplay() {
            if (autoScale) {
                const effectiveGain = calculateEffectiveGain(); // Calcola il gain reale dall'auto-scale
                const autoScaleGainElement = document.getElementById('autoScaleGain');
                if (autoScaleGainElement) {
                    // Mostra solo il gain effettivo calcolato dall'auto-scale
                    autoScaleGainElement.textContent = `${effectiveGain.toFixed(2)}x`;
                    
                    // Colore basato sul gain effettivo
                    if (effectiveGain > 5) {
                        autoScaleGainElement.style.color = '#dc2626';
                    } else if (effectiveGain > 1) {
                        autoScaleGainElement.style.color = '#0369a1';
                    } else {
                        autoScaleGainElement.style.color = '#059669';
                    }
                }
            }
        }

        /**
         * Aggiorna il display del gain nell'area auto-scale
         * Mostra gain effettivo se auto-scale ON, gain manuale se auto-scale OFF
         */
        function updateAutoScaleGainDisplay() {
            const autoScaleGainElement = document.getElementById('autoScaleGain');
            if (autoScaleGainElement) {
                if (autoScale) {
                    // Auto-scale ATTIVO: mostra il gain che l'auto-scale ha calcolato
                    updateEffectiveGainDisplay();
                } else {
                    // Auto-scale DISATTIVO: mostra il gain manuale che stai controllando
                    autoScaleGainElement.textContent = `${yGain.toFixed(2)}x`;
                    
                    // Colore basato sul gain manuale
                    if (yGain > 5) {
                        autoScaleGainElement.style.color = '#dc2626';
                    } else if (yGain > 1) {
                        autoScaleGainElement.style.color = '#0369a1';
                    } else {
                        autoScaleGainElement.style.color = '#059669';
                    }
                }
            }
        }

        /**
         * Inizializza tutti i display del gain (chiamata al caricamento pagina)
         */
        function initializeGainDisplays() {
            updateGainDisplay();           // Inizializza "Total Gain"
            updateAutoScaleGainDisplay();  // Inizializza gain auto-scale
            updateYScaleInfo();           // Inizializza info scala Y
        }

        // =====================================================
        // FUNZIONI MODIFICATE PER INTEGRAZIONE GAIN
        // =====================================================

        /**
         * FUNZIONE PRINCIPALE: Aggiorna la scala Y durante lo streaming
         * Integrata con il sistema di gain
         */
        function updateYScale(newValues) {
            // Se auto-scale è disattivato, non fare nulla automaticamente
            if (!autoScale) return;
            
            // Aggiungi i nuovi valori al buffer per il calcolo della scala
            yScaleBuffer.push(...newValues);
            
            // Mantieni solo gli ultimi Y_SCALE_BUFFER_SIZE valori per performance
            if (yScaleBuffer.length > Y_SCALE_BUFFER_SIZE) {
                yScaleBuffer = yScaleBuffer.slice(-Y_SCALE_BUFFER_SIZE);
            }
            
            if (yScaleBuffer.length === 0) return;
            
            // Calcola min e max dai valori recenti
            const minValue = Math.min(...yScaleBuffer);
            const maxValue = Math.max(...yScaleBuffer);
            
            // Calcola il range base con margine del 10%
            const range = maxValue - minValue;
            const margin = Math.max(range * 0.1, 1000);
            
            // *** QUI È LA MAGIA DEL GAIN ***
            // Applica il gain al range: gain maggiore = range più piccolo = più zoom
            const baseRange = range + 2 * margin;
            const gainedRange = baseRange / yGain;
            
            // Centra la vista sui dati
            const centerValue = (minValue + maxValue) / 2;
            
            // Aggiorna gradualmente la scala per evitare salti bruschi
            const smoothFactor = 0.1;
            const targetMin = centerValue - gainedRange / 2;
            const targetMax = centerValue + gainedRange / 2;
            
            // Smooth transition verso i nuovi valori
            yScale.min = yScale.min + (targetMin - yScale.min) * smoothFactor;
            yScale.max = yScale.max + (targetMax - yScale.max) * smoothFactor;
            
            // Aggiorna il display per mostrare il gain effettivo in tempo reale
            updateEffectiveGainDisplay();
        }

        /**
         * Resetta la scala Y considerando il gain corrente
         */
        function resetYScale() {
            yScaleBuffer = []; // Cancella il buffer
            
            if (yGain === 1.0) {
                // Gain normale: usa i valori di default
                yScale.min = 0;
                yScale.max = 8388608;
            } else {
                // Gain diverso da 1.0: applica il gain ai valori di default
                const defaultCenter = 4194304; // Centro del range di default
                const defaultRange = 8388608;   // Range di default
                const gainedRange = defaultRange / yGain; // Applica il gain
                
                // Centra sul range di default ma con il gain applicato
                yScale.min = defaultCenter - gainedRange / 2;
                yScale.max = defaultCenter + gainedRange / 2;
            }
            
            console.log(`YScale resettata con gain ${yGain}x: ${yScale.min.toFixed(0)} - ${yScale.max.toFixed(0)}`);
        }

        /**
         * Gestisce il toggle dell'auto-scale
         * Integrata per gestire il passaggio gain automatico ↔ gain manuale
         */
        function toggleAutoScale() {
            autoScale = document.getElementById('autoScaleCheckbox').checked;
            console.log("Auto-scaling:", autoScale ? "abilitato" : "disabilitato");
            
            if (autoScale) {
                // Attivazione auto-scale: RESETTA il gain a 1.0 per evitare doppi effetti
                yGain = 1.0;
                
                // Aggiorna i display
                updateGainDisplay();
                updateAutoScaleGainDisplay();
                
                console.log('Auto-scale attivato - gain resettato a 1.0x');
            } else {
                // Disattivazione auto-scale: "congela" il gain corrente
                // Copia il gain effettivo dell'auto-scale come nuovo gain manuale
                const effectiveGain = calculateEffectiveGain();
                yGain = effectiveGain;
                
                // Aggiorna i display per mostrare il nuovo gain manuale
                updateGainDisplay();
                updateAutoScaleGainDisplay();
                
                console.log(`Gain copiato dall'auto-scale: ${effectiveGain.toFixed(2)}x`);
                
                // Ridisegna mantenendo esattamente la stessa vista
                if (inputMode) {
                    drawPlotInc();
                } else {
                    drawPlot();
                }
            }
        }

        /**
         * Aggiorna le info della scala Y mostrandone anche il gain
         */
        function updateYScaleInfo() {
            const infoElement = document.getElementById('yScaleInfo');
            if (infoElement) {
                infoElement.textContent = `Y Range: ${yScale.min.toFixed(0)} to ${yScale.max.toFixed(0)} (Gain: ${yGain.toFixed(2)}x), Current Y center: ${((yScale.min+yScale.max)/2).toFixed(0)}`;
            }
        }

        // =====================================================
        // FUNZIONI DI GESTIONE PRESSIONE CONTINUA
        // =====================================================

        /**
         * Avvia la pressione continua di un pulsante
         * @param {string} buttonId - ID univoco del pulsante
         * @param {Function} actionFunction - Funzione da eseguire ripetutamente
         * @param {number} initialDelay - Ritardo iniziale prima di iniziare la raffica (ms)
         * @param {number} repeatInterval - Intervallo tra le pressioni nella raffica (ms)
         */
        function startContinuousPress(buttonId, actionFunction, initialDelay = 300, repeatInterval = 100) {
            // Esegui immediatamente la prima azione
            actionFunction();
            
            // Avvia la raffica dopo il ritardo iniziale
            buttonPressTimeouts[buttonId] = setTimeout(() => {
                buttonPressIntervals[buttonId] = setInterval(actionFunction, repeatInterval);
            }, initialDelay);
        }

        /**
         * Ferma la pressione continua di un pulsante
         * @param {string} buttonId - ID univoco del pulsante
         */
        function stopContinuousPress(buttonId) {
            // Ferma il timeout iniziale se ancora attivo
            if (buttonPressTimeouts[buttonId]) {
                clearTimeout(buttonPressTimeouts[buttonId]);
                delete buttonPressTimeouts[buttonId];
            }
            
            // Ferma l'intervallo di ripetizione se attivo
            if (buttonPressIntervals[buttonId]) {
                clearInterval(buttonPressIntervals[buttonId]);
                delete buttonPressIntervals[buttonId];
            }
        }

        /**
         * Ferma tutte le pressioni continue attive
         */
        function stopAllContinuousPress() {
            for (let buttonId in buttonPressTimeouts) {
                clearTimeout(buttonPressTimeouts[buttonId]);
            }
            for (let buttonId in buttonPressIntervals) {
                clearInterval(buttonPressIntervals[buttonId]);
            }
            buttonPressTimeouts = {};
            buttonPressIntervals = {};
        }

        /**
         * Configura un pulsante per la pressione continua
         * @param {string} buttonId - ID del pulsante
         * @param {Function} actionFunction - Funzione da eseguire
         * @param {number} initialDelay - Ritardo iniziale (default: 300ms)
         * @param {number} repeatInterval - Intervallo ripetizione (default: 100ms)
         */
        function setupContinuousButton(buttonId, actionFunction, initialDelay = 300, repeatInterval = 100) {
            const button = document.getElementById(buttonId);
            if (!button) {
                console.warn(`Button ${buttonId} not found`);
                return;
            }
            
            // Mouse events
            button.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startContinuousPress(buttonId, actionFunction, initialDelay, repeatInterval);
                
                // Effetto visivo: pulsante premuto
                button.style.transform = 'scale(0.95)';
                button.style.opacity = '0.8';
            });
            
            button.addEventListener('mouseup', () => {
                stopContinuousPress(buttonId);
                
                // Ripristina effetto visivo
                button.style.transform = 'scale(1)';
                button.style.opacity = '1';
            });
            
            button.addEventListener('mouseleave', () => {
                stopContinuousPress(buttonId);
                
                // Ripristina effetto visivo
                button.style.transform = 'scale(1)';
                button.style.opacity = '1';
            });
            
            // Touch events per dispositivi mobili
            button.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startContinuousPress(buttonId, actionFunction, initialDelay, repeatInterval);
                
                // Effetto visivo
                button.style.transform = 'scale(0.95)';
                button.style.opacity = '0.8';
            });
            
            button.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopContinuousPress(buttonId);
                
                // Ripristina effetto visivo
                button.style.transform = 'scale(1)';
                button.style.opacity = '1';
            });
            
            button.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                stopContinuousPress(buttonId);
                
                // Ripristina effetto visivo
                button.style.transform = 'scale(1)';
                button.style.opacity = '1';
            });
        }

        /**
         * Crea e aggiunge i controlli di gain all'interfaccia CON PRESSIONE CONTINUA
        */
        function addYScaleControls() {
			const controlPanel = document.querySelector('.control-panel');
			
			const yScaleDiv = document.createElement('div');
			yScaleDiv.className = 'config-item yscale-controls';
			yScaleDiv.innerHTML = `
				<label><strong>Y Scale Controls:</strong></label>
				<button onclick="resetYScale()">Reset Y Scale</button>
				<button onclick="centerViewOnData()" style="background: #059669; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;">Center on Data</button>
				<label>
					<input type="checkbox" id="autoScaleCheckbox" checked onchange="toggleAutoScale()">
					Auto Scale Y (Gain: <span id="autoScaleGain" style="font-weight: bold; color: #0369a1;">1.0x</span>)
				</label>
				
				<!-- FRECCE DIREZIONALI PER NAVIGAZIONE DATI -->
				<div style="margin: 5px 0; display: flex; align-items: center; gap: 10px; background: #f0f8ff; padding: 8px; border-radius: 4px; border: 1px solid #0ea5e9;">
					<span style="font-size: 12px; color: #0369a1; font-weight: bold;">Navigazione dati:</span>
					
					<!-- Freccia sinistra (indietro nel tempo) -->
					<div id="leftDataArrow" style="display: none; align-items: center; gap: 5px; color: #dc2626; font-weight: bold;">
						<span style="font-size: 18px;">⬅️</span>
						<span style="font-size: 11px;">Usa - o ←</span>
					</div>
					
					<!-- Indicatore centrato -->
					<div id="centeredIndicator" style="display: none; align-items: center; gap: 5px; color: #059669; font-weight: bold;">
						<span style="font-size: 18px;">🎯</span>
						<span style="font-size: 11px;">Centrato</span>
					</div>
					
					<!-- Freccia destra (avanti nel tempo) -->
					<div id="rightDataArrow" style="display: none; align-items: center; gap: 5px; color: #dc2626; font-weight: bold;">
						<span style="font-size: 18px;">➡️</span>
						<span style="font-size: 11px;">Usa + o →</span>
					</div>
				</div>
				
				<div style="margin: 5px 0; display: flex; align-items: center; gap: 15px;">
					<label>Y Gain:</label>
					
					<!-- Prima coppia: +1/-1 -->
					<div style="display: flex; flex-direction: column; align-items: center;">
						<button id="gain-plus-1" style="border: 2px solid #0369a1; padding: 2px 8px; margin: 1px; background: #e0f2fe; cursor: pointer; font-size: 12px;">+</button>
						<span style="font-size: 10px; color: #0369a1; font-weight: bold;">+1/-1</span>
						<button id="gain-minus-1" style="border: 2px solid #0369a1; padding: 2px 8px; margin: 1px; background: #e0f2fe; cursor: pointer; font-size: 12px;">-</button>
					</div>
					
					<!-- Seconda coppia: +10/-10 -->
					<div style="display: flex; flex-direction: column; align-items: center;">
						<button id="gain-plus-10" style="border: 2px solid #dc2626; padding: 2px 8px; margin: 1px; background: #fee2e2; cursor: pointer; font-size: 12px;">+</button>
						<span style="font-size: 10px; color: #dc2626; font-weight: bold;">+10/-10</span>
						<button id="gain-minus-10" style="border: 2px solid #dc2626; padding: 2px 8px; margin: 1px; background: #fee2e2; cursor: pointer; font-size: 12px;">-</button>
					</div>
					
					<!-- Terza coppia: centro normale -->
					<div style="display: flex; flex-direction: column; align-items: center;">
						<button id="center-plus-250k" style="border: 2px solid #059669; padding: 2px 8px; margin: 1px; background: #d1fae5; cursor: pointer; font-size: 12px;">+</button>
						<span style="font-size: 10px; color: #059669; font-weight: bold;">Centro</span>
						<button id="center-minus-250k" style="border: 2px solid #059669; padding: 2px 8px; margin: 1px; background: #d1fae5; cursor: pointer; font-size: 12px;">-</button>
					</div>
					
					<!-- QUARTA coppia: centro fine (5x più preciso) -->
					<div style="display: flex; flex-direction: column; align-items: center;">
						<button id="center-plus-50k" style="border: 2px solid #7c3aed; padding: 2px 8px; margin: 1px; background: #f3e8ff; cursor: pointer; font-size: 12px;">+</button>
						<span style="font-size: 10px; color: #7c3aed; font-weight: bold;">Fine</span>
						<button id="center-minus-50k" style="border: 2px solid #7c3aed; padding: 2px 8px; margin: 1px; background: #f3e8ff; cursor: pointer; font-size: 12px;">-</button>
					</div>
					
					<button onclick="resetGain()" style="margin-left: 10px; background: #ff6b6b; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;">Reset</button>
				</div>
				<div style="margin: 5px 0;">
					<span id="currentGain" style="font-weight: bold; color: #0369a1;">Total Gain: 1.0x</span>
				</div>
				<div id="yScaleInfo" class="yscale-info">Y Range: 0 to 8388608</div>
			`;
			
			controlPanel.appendChild(yScaleDiv);
			
			// Configurazione event listeners per pressione continua (come prima)
			setTimeout(() => {
				setupContinuousButton('gain-plus-1', () => adjustGainBy(1));
				setupContinuousButton('gain-minus-1', () => adjustGainBy(-1));
				setupContinuousButton('gain-plus-10', () => adjustGainBy(10), 400, 150);
				setupContinuousButton('gain-minus-10', () => adjustGainBy(-10), 400, 150);
				setupContinuousButton('center-plus-250k', () => {
					adjustCenterBy(50000);
				}, 300, 80);
				setupContinuousButton('center-minus-250k', () => {
					adjustCenterBy(-50000);
				}, 300, 80);
				setupContinuousButton('center-plus-50k', () => {
					adjustCenterBy(1000);
				}, 300, 60);
				setupContinuousButton('center-minus-50k', () => {
					adjustCenterBy(-1000);
				}, 300, 60);
				
				initializeGainDisplays();
			}, 100);
		}
        // =====================================================
        // TASTI RAPIDI PER IL GAIN (CON ESC DI EMERGENZA)
        // =====================================================

        // Aggiunge controlli con tasti rapidi per il gain
        document.addEventListener('keydown', function(event) {
            // Funziona solo se non stai scrivendo in un campo di testo
            if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
                switch(event.key) {
                    case 'Escape':
                        stopAllContinuousPress(); // Ferma tutto in caso di emergenza
                        console.log('🛑 Tutte le pressioni continue fermate con ESC');
                        event.preventDefault();
                        break;
                    case 'ArrowUp':
                        adjustGainBy(1); // Aumenta di 1
                        event.preventDefault();
                        break;
                    case 'ArrowDown':
                        adjustGainBy(-1); // Diminuisce di 1
                        event.preventDefault();
                        break;
                    case 'PageUp':
                        adjustGainBy(10); // Aumenta di 10
                        event.preventDefault();
                        break;
                    case 'PageDown':
                        adjustGainBy(-10); // Diminuisce di 10
                        event.preventDefault();
                        break;
                    case '1':
                        adjustGainBy(1); // Aumenta di 1
                        event.preventDefault();
                        break;
                    case '2':
                        adjustGainBy(-1); // Diminuisce di 1
                        event.preventDefault();
                        break;
                    case '5':
                        adjustGainBy(10); // Aumenta di 10
                        event.preventDefault();
                        break;
                    case '0':
                        adjustGainBy(-10); // Diminuisce di 10
                        event.preventDefault();
                        break;
                    case 'w':
                    case 'W':
                        adjustCenterBy(150000); // Centro su (normale)
                        event.preventDefault();
                        break;
                    case 's':
                    case 'S':
                        adjustCenterBy(-150000); // Centro giù (normale)
                        event.preventDefault();
                        break;
                    // NUOVI tasti per controllo centro fine
                    case 'q':
                    case 'Q':
                        adjustCenterBy(1000); // Centro su (fine, 5x più preciso)
                        event.preventDefault();
                        break;
                    case 'a':
                    case 'A':
                        adjustCenterBy(-1000); // Centro giù (fine, 5x più preciso)
                        event.preventDefault();
                        break;
                    case 'r':
                    case 'R':
                        resetGain(); // Resetta tutto a 1.0x
                        event.preventDefault();
                        break;
                }
            }
        });

        // =====================================================
        // CLEANUP AUTOMATICO ALLA CHIUSURA PAGINA
        // =====================================================

        window.addEventListener('beforeunload', () => {
            stopAllContinuousPress();
        });

//----------------------------------------------------------------------------------------------------------------------- END OGGI-----------------------------
//----------------------------------------------------------------------------------------------------------------------- END OGGI-----------------------------
        function resizeCanvas() {
            console.log("resizeCanvas");
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            if (inputMode){
                drawPlotInc();
                //currBatchIndex = 20;
            }else{
                playRecord();
             }
        }
				
		function relArea(bidx1, vidx1, bidx2, vidx2, fbody1, fbody2){
			/*if(bidx1 > bidx2){
				let app = bidx1;
				bidx1 = bidx2;
				bidx2 = app;
			}*/
			/*if(vidx1 > vidx2){
				let app = vidx1;
				vidx1 = vidx2;
				vidx2 = app;
			}*/
			//console.log("relArea: bidx1: "+bidx1);
			//console.log("relArea: vidx1: "+vidx1);
			//console.log("relArea: bidx2: "+bidx2);
			//console.log("relArea: vidx2: "+vidx2);
			//console.log("relArea: fbody1: "+fbody1);
			//console.log("relArea: fbody2: "+fbody2);
			
			const g = 9.81;
			let v = 0;
			let s = 0;
			let dt = 0;
			const dt0 = 1/SAMPLE_RATE;
			let currBatchTime = 0;			

			let fbody;
			const firstRawValue = calculateValue(recordBuffer[bidx1].v[vidx1]);
			let precForce = firstRawValue;
			let force;
			let precv = 0;// parte da fermo sia in FDI che in BDI
			if(bidx1 < bidx2){
				fbody = fbody1;
				//console.log("relArea: direct ");
				let batchLen = recordBuffer[0].v.length;
				let precBatchTime = parseInt(recordBuffer[0].t, 16) / 1000000 - dt0;
				for(let batchIdx = bidx1; batchIdx <= bidx2 && batchIdx < recordBuffer.length; batchIdx++) {
					let batch = recordBuffer[batchIdx];
					currBatchTime = parseInt(batch.t, 16) / 1000000;
					dt = (currBatchTime - precBatchTime) / batchLen;
					// Determina gli indici di inizio e fine per questo batch
					let startIdx = (batchIdx === bidx1) ? vidx1+1 : 0;
					let endIdx = (batchIdx === bidx2) ? vidx2 : batch.v.length;
					for(let i = startIdx; i < endIdx && i < batch.v.length; i++) {					
						force = calculateValue(batch.v[i]);
						//console.log("relArea: force: "+force+ ", v: "+v+", s: "+s);
						v = v + (force + precForce - 2*fbody);
						s = s + v + precv;
						precForce = force;
						precv = v;
					}
					precBatchTime = currBatchTime;
				}
			}else{
				fbody = fbody2;
				//console.log("relArea: reverse ");
				let batchLen = recordBuffer[recordBuffer.length - 1].v.length;
				let precBatchTime = parseInt(recordBuffer[recordBuffer.length - 1].t, 16) / 1000000 - dt0;
				for(let batchIdx = bidx1; batchIdx >= bidx2 && batchIdx >= 0; batchIdx--) {
					let batch = recordBuffer[batchIdx];
					currBatchTime = parseInt(batch.t, 16) / 1000000;
					dt = (precBatchTime - currBatchTime) / batchLen;
					// Determina gli indici di inizio e fine per questo batch
					let startIdx = (batchIdx === bidx1) ? vidx1-1 : batchLen - 1;
					let endIdx = (batchIdx === bidx2) ? vidx2 : 0;
					for(let i = startIdx; i >= endIdx && i >= 0; i--) {					
						force = calculateValue(batch.v[i]);
						
						v = v + (force + precForce - 2*fbody);
						s = s + v + precv;
						//console.log("relArea: force: "+force+", precForce: "+precForce+ ", v: "+v+", s: "+s, "fbody: "+fbody, "fbody2: "+fbody2);
						precForce = force;
						precv = v;
					}
					precBatchTime = currBatchTime;
				}
			}
			//console.log("diffForce: "+vIniziale);
			v =  v*dt0/2/fbody*g;
			//console.log("relArea: v: "+v);
			let h_velocity = (v * v) / (2 * g);//console.log("relArea: h_velocity: "+h_velocity);
			heelLift = s*dt0*dt0/4/fbody*g;// air distance + heel-lift distance	
			//console.log("relArea: heelLift: "+heelLift);
			return {hv: h_velocity, hl: heelLift, ht: h_velocity + heelLift, v: v};
		}
		
        function analyzeJump(recordBuffer, sampleRate, bIdx, vIdx, index, t12, sw2, sd) {
			const result = detectJumpThresholds(recordBuffer, sampleRate, bIdx, vIdx, t12, sw2, sd);	
			//if(!result.next) return null;
			console.log('------------------------------------------------------------');
			console.log('analyzeJump-bIdx: '+bIdx);
			console.log('analyzeJump-vIdx: '+vIdx);
			console.log('analyzeJump-Fstatico: '+Fstatico);
			//
			console.log('analyzeJump-sd: '+sd);
			console.log('result.next: '+result.next);
			console.log('------------------------------------------------------------');
			// Calcoli finali
			const g = 9.81;
			let flightTime = 0;
			let h_flight = 0;
			
			if(result.t4){
				Fstatico1 = result.sw1;
				Fstatico2 = result.sw2;
				Fstatico = (result.sw1 + result.sw2) / 2;
				if(result.sd){
					globalSDMean = result.sd;
					console.log('analyzeJump-sd: '+sd);
				}		
				flightTime = result.t5.time - result.t4.time;
				h_flight = (g * flightTime * flightTime) / 8;// altezza da tempo di volo
				//console.log('h_flight: '+h_flight);
			}
			
			if(result.t1 != null && result.t4 != null && result.t5 != null && result.t6 != null){
				r1 = relArea(result.t1.bidx, result.t1.vidx, result.t4.bidx, result.t4.vidx, result.sw1, result.sw2);	
				r2 = relArea(result.t6.bidx, result.t6.vidx, result.t5.bidx, result.t5.vidx, result.sw1, result.sw2);
				
				return {
					index,
					flightTime,
					height_from_time: h_flight,
					height_from_takeoff_velocity: r1.hv,
					height_from_landing_velocity: r2.hv,
					takeoff_heelLift: r1.hl,
					landing_heelLift: r2.hl,
					takeoff_total_height: r1.hv + r1.hl,
					landing_total_height: r2.hv + r2.hl,
					takeoff_velocity: r1.v,
					landing_velocity: r2.v,				
					thresholdTimes: result
				};
			}else{
						
				return {
					index,
					flightTime,
					height_from_time: null,
					height_from_takeoff_velocity: null,
					height_from_landing_velocity: null,
					takeoff_heelLift: null,
					landing_heelLift: null,
					takeoff_total_height: null,
					landing_total_height: null,
					takeoff_velocity: null,
					landing_velocity: null,				
					thresholdTimes: result
				};
			}
		}
		
        function printJumpReport(data) {
            // Console report
            console.table({
				"Jump number": `${(data.index+1).toFixed(0)}`,
                "Flight Time": `${(data.flightTime * 1000).toFixed(3)} ms`,
                "Height from flyght time: ": `${(data.height_from_time * 100).toFixed(3)} cm`,
                "Height from takeoff velocity (FDI)": `${(data.height_from_takeoff_velocity * 100).toFixed(3)} cm`, 
				"Takeoff heelLift: ": `${(data.takeoff_heelLift * 100).toFixed(3)} cm`, 
				"Total height from takeoff (FDI + heel lift): ": `${(data.takeoff_total_height * 100).toFixed(3)} cm`, 
                "Height from landing velocity (BDI)": `${(data.height_from_landing_velocity * 100).toFixed(3)} cm`, 
				"Landing heelLift: ": `${(data.landing_heelLift * 100).toFixed(3)} cm`, 
				"Total height from landing (BDI + heel lift): ": `${(data.landing_total_height * 100).toFixed(3)} cm`, 
                "Time Events": {
                    "Start of Movement (t1)": `${data.thresholdTimes.t1.time.toFixed(3)} ms`,
                    "Max Descent Speed (t2)": `${data.thresholdTimes.t2.time.toFixed(3)} ms`, 
                    "Max Ascent Speed (t3)": `${data.thresholdTimes.t3.time.toFixed(3)} ms`,
                    "Takeoff (t4)": `${data.thresholdTimes.t4.time.toFixed(3)} ms`,
                    "Landing (t5)": `${data.thresholdTimes.t5.time.toFixed(3)} ms`
                }
            });

            // HTML report
            const div = document.createElement('div');
            div.innerHTML = `
                <div class="jump-report" style="font-family: Arial; padding: 20px; max-width: 600px; margin: auto;">
                    <h2>Jump ${(data.index).toFixed(0)} Analysis Report</h2>
                    
                    <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
                        <h3>Jump Heights</h3>
                        <p>From Flight Time: <strong>${(data.height_from_time * 100).toFixed(3)} cm</strong></p>
                        <p>From takeoff velocity: <strong>${(data.height_from_takeoff_velocity * 100).toFixed(3)} cm</strong></p>
						<p>Takeoff heel lift displacement: <strong>${(data.takeoff_heelLift * 100).toFixed(3)} cm</strong></p>
						<p>From displacement and takeoff velocity: <strong>${(data.takeoff_total_height * 100).toFixed(3)} cm</strong></p>
                        <p>From landing velocity: <strong>${(data.height_from_landing_velocity * 100).toFixed(3)} cm</strong></p>
						<p>Landing heel lift displacement: <strong>${(data.landing_heelLift * 100).toFixed(3)} cm</strong></p>
						<p>From displacement and landing velocity: <strong>${(data.landing_total_height * 100).toFixed(3)} cm</strong></p>
                    </div>

                    <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
                        <h3>Time Metrics</h3>
                        <p>Flight Time: <strong>${(data.flightTime * 1000).toFixed(1)} ms</strong></p>
                    </div>

                    <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
                        <h3>Velocity Metrics</h3>
                        <p>Takeoff Velocity: <strong>${data.takeoff_velocity.toFixed(2)} m/s</strong></p>
                        <p>Landing Velocity: <strong>${data.landing_velocity.toFixed(2)} m/s</strong></p>
                    </div>

                    <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
                        <h3>Time Events</h3>
                        <p>Start of Movement (t1): <strong>${data.thresholdTimes.t1.time.toFixed(3)} ms</strong></p>
                        <p>Max Descent Speed (t2): <strong>${data.thresholdTimes.t2.time.toFixed(3)} ms</strong></p>
                        <p>Max Ascent Speed (t3): <strong>${data.thresholdTimes.t3.time.toFixed(3)} ms</strong></p>
                        <p>Takeoff (t4): <strong>${data.thresholdTimes.t4.time.toFixed(3)} ms</strong></p>
                        <p>Landing (t5): <strong>${data.thresholdTimes.t5.time.toFixed(3)} ms</strong></p>
                    </div>
                </div>
            `;
            document.getElementById('report').appendChild(div);
            return div;
        }
		// =====================================================
		// SISTEMA DI SALVATAGGIO/CARICAMENTO AVANZATO CON METADATI
		// =====================================================
		
				// Modifica la funzione loadRecord per gestire i metadati (RETROCOMPATIBILE)
		async function loadRecord(file) {
			console.log("loadRecordWithMetadata - Retrocompatibile");
			if (!file) return;
			
			try {
				const text = await file.text();
				const lines = text.split('\n').filter(line => line.trim());
				
				let metadata = null;
				let dataStartIndex = 0;
				let hasMetadata = false;
				
				// Controlla se la prima riga contiene metadati
				if (lines.length > 0) {
					try {
						const firstLine = JSON.parse(lines[0]);
						if (firstLine.type === "METADATA") {
							metadata = firstLine;
							dataStartIndex = 1;
							hasMetadata = true;
							console.log('✅ File CON metadati trovato:', metadata);
						}
					} catch (e) {
						console.log('📁 File SENZA metadati (formato vecchio) - Retrocompatibilità attiva');
					}
				}
				
				// Carica i batch (saltando la prima riga se contiene metadati)
				loadBuffer.length = 0;
				loadBuffer = lines.slice(dataStartIndex).map(line => {
					const hexBatch = JSON.parse(line);
					return {
						t: hexBatch.t,
						v: hexBatch.v
					};
				});
								
				// Gestione metadati con retrocompatibilità
				if (hasMetadata) {
					// File nuovo con metadati: applica i metadati salvati
					applyMetadataToView(metadata);
					showToast('File caricato con metadati salvati', 'success');
				} else {
					// File vecchio senza metadati: usa impostazioni di default ma segna come "da salvare"
					console.log('🔄 File vecchio senza metadati - Applicazione impostazioni di default');
					
					// Resetta a valori di default
					yGain = 1.0;
					resetYScale();
					
					// Aggiorna tutti i display
					updateGainDisplay();
					updateAutoScaleGainDisplay();
					updateYScaleInfo();
					
					// Segna che il file necessita di metadati al prossimo salvataggio
					markFileAsNeedingMetadata();
					
					showToast('File vecchio caricato - Metadati saranno aggiunti al salvataggio', 'info');
				}
				
				console.log(`📊 Caricati ${recordBuffer.length} batch - Metadati: ${hasMetadata ? 'Presenti' : 'Assenti'}`);
				
			} catch (error) {
				console.error('❌ Errore durante il caricamento del record:', error);
				showToast('Errore nel caricamento del file', 'error');
				alert('Errore nel caricamento del file. Verifica che sia un file valido.');
			}
		}
		
		document.getElementById('recordFileInput').addEventListener('change', function(e) {
			loadRecord(e.target.files[0]);
		});
		
		document.getElementById('play').addEventListener('click', function(e) {
			playRecord();
		});
		
		// Modifica playRecord per usare la nuova versione
		function playRecord() {
			playRecordWithMetadata(); // <-- Usa la nuova funzione
		}
		
		// Aggiungi questa funzione per salvare con metadati
		function saveRecordedBatchesWithMetadata() {
			// Calcola il centro corrente della vista Y
			const currentCenter = (yScale.max + yScale.min) / 2;
			
			// Crea il JSON dei metadati
			const metadata = {
				type: "METADATA",
				version: "1.0",
				timestamp: new Date().toISOString(),
				yGain: yGain,
				currentCenter: currentCenter,
				yScaleMin: yScale.min,
				yScaleMax: yScale.max,
				sampleRate: SAMPLE_RATE,
				bufferDurationSec: bufferDurationSec,
				totalBatches: recordBuffer.length,
				notes: "File saved with Y-scale metadata for accurate playback"
			};
			
			// Crea il contenuto del file: prima i metadati, poi i batch
			let content = JSON.stringify(metadata) + '\n';
			
			// Aggiungi tutti i batch
			content += recordBuffer.map(batch => {
				const hexBatch = {
					t: batch.t,
					v: batch.v
				};
				return JSON.stringify(hexBatch);
			}).join('\n');
			
			// Salva il file
			const blob = new Blob([content], { type: 'text/plain' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = getDefaultFileName();
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			URL.revokeObjectURL(url);
			
			console.log('File salvato con metadati:', metadata);
		}

		// Nuova funzione per segnare i file senza metadati
		let fileNeedsMetadata = false;

		function markFileAsNeedingMetadata() {
			fileNeedsMetadata = true;
			
			// Mostra un indicatore visivo che il file verrà aggiornato
			const saveBtn = document.getElementById('saveMetadataBtn');
			if (saveBtn) {
				saveBtn.style.background = '#f59e0b'; // Arancione per indicare "da aggiornare"
				saveBtn.title = 'File vecchio caricato - Clicca per salvare con metadati aggiornati';
				saveBtn.textContent = 'Add Metadata';
				
				// Lampeggia brevemente per attirare l'attenzione
				let blinkCount = 0;
				const blinkInterval = setInterval(() => {
					saveBtn.style.opacity = saveBtn.style.opacity === '0.5' ? '1' : '0.5';
					blinkCount++;
					if (blinkCount >= 6) { // 3 lampeggi
						clearInterval(blinkInterval);
						saveBtn.style.opacity = '1';
					}
				}, 300);
			}
			
			console.log('🏷️ File marcato come bisognoso di metadati');
		}

		// Nuova funzione per applicare i metadati alla vista
		function applyMetadataToView(metadata) {
			console.log('Applicazione metadati alla vista...');
			
			// Ripristina il gain salvato
			if (metadata.yGain !== undefined) {
				yGain = metadata.yGain;
				console.log(`Gain ripristinato: ${yGain}x`);
			}
			
			// Ripristina la scala Y salvata
			if (metadata.yScaleMin !== undefined && metadata.yScaleMax !== undefined) {
				yScale.min = metadata.yScaleMin;
				yScale.max = metadata.yScaleMax;
				console.log(`Scala Y ripristinata: ${yScale.min} - ${yScale.max}`);
			} else if (metadata.currentCenter !== undefined) {
				// Fallback: usa centro e gain per ricostruire la scala
				const standardRange = 8388608;
				const newRange = standardRange / yGain;
				yScale.min = metadata.currentCenter - newRange / 2;
				yScale.max = metadata.currentCenter + newRange / 2;
				console.log(`Scala Y ricostruita da centro: ${yScale.min} - ${yScale.max}`);
			}
			
			// Ripristina sample rate se diverso
			if (metadata.sampleRate !== undefined && metadata.sampleRate !== SAMPLE_RATE) {
				SAMPLE_RATE = metadata.sampleRate;
				document.getElementById('sampleRate').value = SAMPLE_RATE;
				console.log(`Sample rate ripristinato: ${SAMPLE_RATE}`);
			}
			
			// Aggiorna tutti i display
			updateGainDisplay();
			updateAutoScaleGainDisplay();
			updateYScaleInfo();
			
			// Mostra info sui metadati caricati
			showMetadataInfo(metadata);
		}

		// Funzione per mostrare le informazioni sui metadati caricati
		function showMetadataInfo(metadata) {
			const info = `
		📁 File caricato con metadati:
		• Gain: ${metadata.yGain}x
		• Centro Y: ${metadata.currentCenter}
		• Range Y: ${metadata.yScaleMin} - ${metadata.yScaleMax}
		• Sample Rate: ${metadata.sampleRate} Hz
		• Batch totali: ${metadata.totalBatches}
		• Salvato: ${new Date(metadata.timestamp).toLocaleString()}
			`;
			
			console.log(info);
			
			// Mostra temporaneamente un toast
			showToast('Metadati caricati con successo!', 'success');
		}

		// Funzione per salvare solo i metadati correnti (tasto Save) - RETROCOMPATIBILE
		function saveCurrentMetadata() {
			if (recordBuffer.length === 0) {
				alert('Nessun dato da salvare. Carica prima una traccia.');
				return;
			}
			
			const currentCenter = (yScale.max + yScale.min) / 2;
			
			const metadata = {
				type: "METADATA",
				version: "1.0",
				timestamp: new Date().toISOString(),
				yGain: yGain,
				currentCenter: currentCenter,
				yScaleMin: yScale.min,
				yScaleMax: yScale.max,
				sampleRate: SAMPLE_RATE,
				bufferDurationSec: bufferDurationSec,
				totalBatches: recordBuffer.length,
				notes: fileNeedsMetadata ? 
					"Legacy file updated with metadata for first time" : 
					"Updated metadata for existing trace"
			};
			
			// Ricrea il file con i nuovi metadati
			let content = JSON.stringify(metadata) + '\n';
			
			// Aggiungi tutti i batch esistenti
			content += recordBuffer.map(batch => {
				const hexBatch = {
					t: batch.t,
					v: batch.v
				};
				return JSON.stringify(hexBatch);
			}).join('\n');
			
			// Determina il nome del file
			const blob = new Blob([content], { type: 'text/plain' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			
			// Nome file appropriato
			let fileName;
			if (fileNeedsMetadata) {
				// File vecchio: aggiungi suffisso _with_metadata
				const originalName = getDefaultFileName();
				const nameParts = originalName.split('.');
				if (nameParts.length > 1) {
					nameParts[nameParts.length - 2] += '_with_metadata';
				} else {
					nameParts[0] += '_with_metadata';
				}
				fileName = nameParts.join('.');
			} else {
				// File già con metadati: aggiungi suffisso _updated
				const originalName = getDefaultFileName();
				const nameParts = originalName.split('.');
				if (nameParts.length > 1) {
					nameParts[nameParts.length - 2] += '_updated';
				} else {
					nameParts[0] += '_updated';
				}
				fileName = nameParts.join('.');
			}
			
			a.download = fileName;
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			URL.revokeObjectURL(url);
			
			// Reset del flag e aggiornamento UI
			if (fileNeedsMetadata) {
				fileNeedsMetadata = false;
				const saveBtn = document.getElementById('saveMetadataBtn');
				if (saveBtn) {
					saveBtn.style.background = '#059669'; // Verde normale
					saveBtn.title = 'Salva gain e centro correnti nel file';
					saveBtn.textContent = 'Save Metadata';
				}
				showToast('File vecchio aggiornato con metadati!', 'success');
			} else {
				showToast('Metadati aggiornati e salvati!', 'success');
			}
			
			console.log('💾 Metadati salvati:', metadata);
		}

		// Funzione di utilità per mostrare notifiche toast
		function showToast(message, type = 'info') {
			// Rimuovi toast precedenti
			const existingToast = document.getElementById('toast');
			if (existingToast) {
				existingToast.remove();
			}
			
			// Crea nuovo toast
			const toast = document.createElement('div');
			toast.id = 'toast';
			toast.style.cssText = `
				position: fixed;
				top: 20px;
				right: 20px;
				padding: 15px 20px;
				border-radius: 5px;
				color: white;
				font-weight: bold;
				z-index: 10000;
				transition: opacity 0.3s;
				${type === 'success' ? 'background: #059669;' : 
				  type === 'error' ? 'background: #dc2626;' : 
				  'background: #0369a1;'}
			`;
			toast.textContent = message;
			
			document.body.appendChild(toast);
			
			// Rimuovi dopo 3 secondi
			setTimeout(() => {
				toast.style.opacity = '0';
				setTimeout(() => toast.remove(), 300);
			}, 3000);
		}

		// Modifica la funzione playRecord per usare i metadati
		function playRecordWithMetadata() {
			updateTimebase();
			document.getElementById('report').innerHTML = ''; // cancella i report precedenti
			// Disabilita il modo test se attivo
			adcSignalEnabled = false;
			testSignalEnabled0 = false;
			testSignalEnabled1 = false;
			if(isStreaming) {
				toggleStreaming();
			}
			inputMode = false;
			recordBuffer = recordBuffer.slice(0, maxBufferSize);
			currPlayIndex = 0;
			
			let ofst = Number(document.getElementById('startOffset').value)/1000;
			
			recordBuffer.length = 0;
			recordBuffer = applyEMAFilter(loadBuffer.slice(ofst / 0.005), parseFloat(document.getElementById('emaAlpha').value));
			const firstBatch = recordBuffer[0];
			const lastBatch = recordBuffer[recordBuffer.length - 1];
			const dataStartTime = parseInt(firstBatch.t, 16);
			const dataEndTime = parseInt(lastBatch.t, 16);
			const dataCenterTime = (dataStartTime + dataEndTime) / 2;	
			// Centratura intelligente sui dati (come prima)
			if (recordBuffer.length > 0) {				
				const currentTimeWindow = timebaseDiv * DIVISIONS_X * 1000000;
				xScale.min = dataCenterTime - currentTimeWindow / 2;
				xScale.max = dataCenterTime + currentTimeWindow / 2;
				
				console.log(`Playback centrato: centro dati=${dataCenterTime}, finestra=${currentTimeWindow}`);
			}
			
			// I metadati Y sono già stati applicati durante il caricamento
			// Non fare auto-scaling automatico qui
			// Analisi del salto e report
			let index = 0;
			let report = {};
			let bIdx = 0;
			let vIdx = 0;
			let t12 = null;
			let sw2 = 0;
			let sd = 0;
			thresholdsList.length = 0;
			do{
				report = analyzeJump(recordBuffer, SAMPLE_RATE, bIdx, vIdx, index, t12, sw2, sd); 		  
				index++;
				console.log('index: '+index);	
				bIdx = report.thresholdTimes.t12bidx;
				vIdx = report.thresholdTimes.t12vidx;
				t5 = report.thresholdTimes.t5;
				t12 = report.thresholdTimes.t12;
				sw2 = report.thresholdTimes.sw2;
				sd = report.thresholdTimes.sd;
				console.log(`next: `+report.thresholdTimes.next);
				if(t5 != null){
					printJumpReport(report);
					thresholdsList.push(report.thresholdTimes);		
				}					
			}while(report.thresholdTimes.next);
			drawPlot();       
			scrollView(0);
		}
		
		// Funzione per applicare un filtro EMA a un buffer di batch {t, v}
		// dove v è un array di stringhe esadecimali
		// Restituisce una nuova lista con gli stessi t e i valori filtrati
		function applyEMAFilter(loadBuffer, alpha = 1) {
			if (!loadBuffer || loadBuffer.length === 0) {
				return [];
			}
			
			if(alpha == 1) return loadBuffer;
			
			const firstBatch = loadBuffer[0];
	
			if (!firstBatch.v || !Array.isArray(firstBatch.v)) {
				return [];
			}
			
			const arrayLength = firstBatch.v.length;
			const filteredBuffer = [];
			
			// Aggiungi il primo batch invariato
			filteredBuffer.push({
				t: firstBatch.t,
				v: [...firstBatch.v]
			});
			
			let emaValue = calculateValue(firstBatch.v[0]);;
			
			// Applica il filtro EMA a ogni batch successivo
			for (let i = 1; i < loadBuffer.length; i++) {
				const currentBatch = loadBuffer[i];
				
				if (!currentBatch.v || !Array.isArray(currentBatch.v) || currentBatch.v.length !== arrayLength) {
					continue;
				}
				
				const newV = [];
				
				// Per ogni elemento dell'array v
				for (let j = 0; j < arrayLength; j++) {
					const currentValue = calculateValue(currentBatch.v[j]);
					
					// Formula EMA: EMA = alpha * valore_corrente + (1 - alpha) * EMA_precedente
					emaValue = alpha * currentValue + (1 - alpha) * emaValue;
					
					newV.push(Math.round(emaValue).toString(16).padStart(6, '0'));
				}
				
				// Crea un nuovo batch con timestamp originale e valori filtrati
				filteredBuffer.push({
					t: currentBatch.t,
					v: newV
				});
			}
			
			return filteredBuffer;
		}


		// Funzione per aggiornare i controlli HTML
		function addSaveLoadControls() {
			// Trova i controlli esistenti per il recording
			const recordBtn = document.getElementById('recordBtn');
			const loadRecordBtn = document.getElementById('loadRecordBtn');
			
			if (recordBtn && loadRecordBtn) {
				// Modifica il testo del load button per chiarire che carica con metadati
				loadRecordBtn.title = 'Carica traccia con metadati Y-scale';
				
				// Crea il pulsante Save per salvare metadati aggiornati
				const saveBtn = document.createElement('button');
				saveBtn.id = 'saveMetadataBtn';
				saveBtn.textContent = 'Save Metadata';
				saveBtn.title = 'Salva gain e centro correnti nel file';
				saveBtn.style.cssText = `
					background: #059669;
					color: white;
					border: none;
					padding: 4px 8px;
					border-radius: 3px;
					cursor: pointer;
					margin-left: 5px;
				`;
				saveBtn.onclick = saveCurrentMetadata;
				
				// Inserisci il pulsante dopo il load button
				loadRecordBtn.parentNode.insertBefore(saveBtn, loadRecordBtn.nextSibling);
				
				console.log('Controlli di salvataggio/caricamento con metadati aggiunti');
			}
		}

		// Modifica le funzioni esistenti per usare le nuove versioni
		function toggleRecording() {
			if (!isRecording) {
				// Start recording
				recordBuffer = []; // Reset buffer
				isRecording = true;
				document.getElementById('recordBtn').innerHTML = 'Stop Recording';
			} else {
				// Stop and save WITH METADATA
				isRecording = false;
				saveRecordedBatchesWithMetadata(); // <-- Usa la nuova funzione
				document.getElementById('recordBtn').innerHTML = 'Start Recording';
			}
		}
		// =====================================================
		// ESEMPI DI FORMATO FILE CON METADATI
		// =====================================================

		/*
		ESEMPIO di file salvato con metadati:

		{"type":"METADATA","version":"1.0","timestamp":"2025-07-01T10:30:00.000Z","yGain":60,"currentCenter":36304,"yScaleMin":-33601,"yScaleMax":106209,"sampleRate":30000,"bufferDurationSec":10,"totalBatches":500,"notes":"File saved with Y-scale metadata for accurate playback"}
		{"t":1655484153000000,"v":["400000","400001","400002",...]}
		{"t":1655484153005000,"v":["400010","400011","400012",...]}
		...

		La prima riga contiene sempre i metadati (riconoscibile da "type":"METADATA")
		Le righe successive contengono i batch di dati come prima
		*/
	
		// Funzione per aggiungere i controlli metadati
		function addMetadataControls() {
			const controlPanel = document.querySelector('.control-panel');
			
			// Trova i controlli di recording esistenti
			const recordBtn = document.getElementById('recordBtn');
			const loadRecordBtn = document.getElementById('loadRecordBtn');
			
			if (recordBtn && loadRecordBtn) {
				// Aggiungi i nuovi pulsanti
				const saveBtn = document.createElement('button');
				saveBtn.id = 'saveMetadataBtn';
				saveBtn.textContent = 'Save with Metadata';
				saveBtn.onclick = saveCurrentMetadata;
				saveBtn.style.cssText = `
					background: #059669;
					color: white;
					border: none;
					padding: 4px 8px;
					border-radius: 3px;
					cursor: pointer;
					margin-left: 5px;
				`;
							
				// Inserisci i pulsanti
				loadRecordBtn.parentNode.insertBefore(saveBtn, loadRecordBtn.nextSibling);
				console.log('✅ Controlli metadati aggiunti');
			}
		}
		
		// Funzione per creare template metadati vuoto
		function createMetadataTemplate() {
			const template = {
				type: "METADATA",
				version: "1.0",
				timestamp: new Date().toISOString(),
				yGain: 1.0,
				currentCenter: 4194304,
				yScaleMin: 0,
				yScaleMax: 8388608,
				sampleRate: 30000,
				bufferDurationSec: 10,
				totalBatches: 0,
				autoScale: true,
				notes: "Template metadati - modifica i valori secondo necessità"
			};
			
			return JSON.stringify(template, null, 2);
		}
		
		/**
		 * Formatta la distanza temporale in modo leggibile
		 */
		function formatTimeDistance(microseconds) {
			if (microseconds > 1000000) {
				return `${(microseconds / 1000000).toFixed(1)}s`;
			} else if (microseconds > 1000) {
				return `${(microseconds / 1000).toFixed(1)}ms`;
			} else {
				return `${microseconds.toFixed(0)}μs`;
			}
		}
		
		function centerViewOnData() {
			 if (!inputMode && recordBuffer.length > 0) {
				const firstBatch = recordBuffer[0];
				const lastBatch = recordBuffer[recordBuffer.length - 1];
				
				const dataStartTime = parseInt(firstBatch.t, 16);
				const dataEndTime = parseInt(lastBatch.t, 16);
				const dataCenterTime = (dataStartTime + dataEndTime) / 2;
				
				const currentTimeWindow = timebaseDiv * DIVISIONS_X * 1000000;
				
				xScale.min = dataCenterTime - currentTimeWindow / 2;
				xScale.max = dataCenterTime + currentTimeWindow / 2;
				
				drawPlot();
				console.log(`Vista centrata automaticamente sui dati: centro=${dataCenterTime}`);
			}
		}

        function scrollView(deltaMs) {
			console.log("scrollView: "+deltaMs);
			if (recordBuffer.length === 0) return;

			const timeWindow = timebaseDiv * DIVISIONS_X * 1000000;
			console.log("scrollView timeWindow: "+timeWindow);
			
			xScale.min += deltaMs;
			xScale.max = xScale.min + timeWindow;
			console.log("scrollView xScale.min: "+xScale.min);
			console.log("scrollView xScale.max: "+xScale.max);
			
			drawPlot();
		}

        function drawThresholds() {
			//console.log("timesList: "+thresholdsList );
			if (recordBuffer.length > 0 && thresholdsList != undefined) {
				//console.log("thresholdsList.length: "+thresholdsList.length );
				for (const times of thresholdsList) {
					//console.log("rrr: "+thresholdsList );
					
					ctx.save();
					
					// Linee
					ctx.strokeStyle = 'green';
					ctx.lineWidth = 2;
					ctx.setLineDash([5, 5]);
					
					// Testo
					ctx.font = '12px Arial';
					ctx.fillStyle = 'green';
					ctx.textAlign = 'left';
					ctx.setLineDash([]); // Rimuove tratteggio per il testo
					
					const labels = {
						t1: 'T1: Start',
						t2: 'T2: Max Down',
						t3: 'T3: Max Up', 
						t4: 'T4: Takeoff',
						t5: 'T5: Landing',
						t6: 'T6: End Landing',
						t7: 'T7: End quite standing',
						t12: 'T12: Next Start'
					};
					
					let count = 0;
					for (const [key, label] of Object.entries(labels)) {
						if (key in times) {
							if(times[key] != null){
								const x = timeToScreen(times[key].time * 1000000);
								// Linea
								ctx.beginPath();
								ctx.moveTo(x, padding);
								ctx.lineTo(x, canvas.height - padding);
								ctx.stroke();
								
								// Etichetta
								ctx.fillText(label, x + 5, padding + 20 + count);
							}
						}
						count +=10;
					}
					
					ctx.restore();
					//console.log("Times:", times);
					//console.log("Window:", {min: xScale.min, max: xScale.max});
				}
			}
        }

        function drawScrollLimits() {
            if (recordBuffer.length > 0) {
                const firstTime = recordBuffer[0].t;
                const lastTime = recordBuffer[recordBuffer.length - 1].t;
                
                ctx.save();
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);               

                // Limite sinistro
                const x1 = timeToScreen(firstTime);
                ctx.beginPath();
                ctx.moveTo(x1, padding);
                ctx.lineTo(x1, canvas.height - padding);
                ctx.stroke();
                
                // Limite destro
                const x2 = timeToScreen(lastTime);
                ctx.beginPath();
                ctx.moveTo(x2, padding);
                ctx.lineTo(x2, canvas.height - padding);
                ctx.stroke();
                
                ctx.restore();
            }
        }

        function calculateValue(hexString) {
            let value = parseInt(hexString, 16);
            if (value & 0x800000) value -= 0x1000000;
            return value;
        }
//-------------------------------------------------------------------------------------------------------------
        function drawPlotInc() {
            // Cancella l'animazione precedente se esiste
            if (animationFrameId && currBatchIndex > 2) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                //console.log("Animazione precedente cancellata.");
            }

            // Verifica buffer vuoto
            if (batchBuffer.length === 0) {
                //console.log("Buffer vuoto, nessun dato da disegnare.");
                return;
            }

            function draw(timestamp, index) {
                // Salva lo stato iniziale del contesto grafico
                //ctx.save();

                //ctx.beginPath();
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;

                const batch = batchBuffer[index];
              
                // Test dei range
                const timeInRange = batch && (parseInt(batch.t, 16) >= xScale.min && parseInt(batch.t, 16) <= xScale.max);
                //console.log(`Batch ${index} - Time range: ${timeInRange} (${batch.t})`);

                if (timeInRange) {
                    let value = parseInt(batch.v[0], 16);
                    if (value & 0x800000) value -= 0x1000000;
                   
				    updateYScale([value]);
                    //console.log("value: "+value);
                    // Calcola coordinate
                    //const x = timeToScreen(batch.t);

                    const x = timeToScreen(parseInt(batch.t, 16));
                    //const y = valueToScreen(value);

                    //const x = timeToScreen(xScale.min + index*5000);
                    const y = valueToScreen(value);
                    //console.log(`Coordinate: x=${x}, y=${y}, minx=${xScale.min}, maxx==${xScale.max}`);
                    //console.log(`Coordinate: x=${x}, y=${batch.first}`);
                    // Test coordinate nel plot
                    const inPlotArea = x >= padding && x <= canvas.width - padding &&
                                    y >= padding && y <= canvas.height - padding;
                    //console.log(`Coordinate in area plot: ${inPlotArea}`);

                    if (true) {
                        if (index === 0) {
                            // Reset e primo punto
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            drawGrid();
                            drawAxes();
                            ctx.beginPath();
                            ctx.moveTo(x, y);                            
                            console.log(`Reset e MoveTo: ${x},${y}`);
                        } else {
                            // Punti successivi
                            //ctx.moveTo(lastX, lastY);
                            ctx.lineTo(x, y);
                            //console.log(`LineTo: ${x},${y}`);
                        }
                        ctx.stroke();
                    }
                }

                // Ripristina lo stato iniziale del contesto grafico
                //ctx.restore();

                // Aggiorna l'ultimo punto
            }
            
            // Pianifica il prossimo frame se non in pausa
            if (!isPaused) {
                animationFrameId = requestAnimationFrame(((value) => (timestamp) => {
                                        draw(timestamp, value); // Cattura il valore corrente di `dynamicValue`
                                    })(currBatchIndex)); // Passa una copia al wrapper
                //console.log("Frame pianificato");
            }
        }
//--------------------------------------------------------------------------------------------------------------------------
        function drawPlot() {
			if (animationFrameId) {
				cancelAnimationFrame(animationFrameId);
			}
			animationFrameId = requestAnimationFrame(() => {
				if (recordBuffer.length === 0) return;
				const timeWindow = timebaseDiv * DIVISIONS_X * 1000000;
				
				// Clear e disegna griglia
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				drawGrid();
				drawAxes();
				
				// Plot dei dati
				ctx.beginPath();
				ctx.strokeStyle = 'blue';
				ctx.lineWidth = 2;
				let isFirstPoint = true;
				let lastX = -1;
				let lastY = -1;
				let n = 1;
				
				// Prima trova i batch nella finestra temporale
				const batchesInWindow = recordBuffer.filter(batch => 
					parseInt(batch.t, 16) >= xScale.min && parseInt(batch.t, 16) <= xScale.max
				);
				
				// Calcolo Risoluzione Dinamica
				if(batchesInWindow.length < TARGET_POINTS){
					n = Math.ceil((TARGET_POINTS - batchesInWindow.length) / batchesInWindow.length)+1;
					n = Math.min(n, recordBuffer[0].v.length);
				}
				
				// Disegna tutti i punti nella finestra temporale corrente
				let count = 0;				
				for (let batch of batchesInWindow) {
					for(let j=0; j < n; j++){  
						// filtra i campioni                      
						value = calculateValue(batch.v[j]);
						
						// Calcola il timestamp preciso per questo campione nel batch
						const sampleTime = parseInt(batch.t, 16) + (j * (1000000 / SAMPLE_RATE)); // in microsecondi
				
						const x = Math.round(timeToScreen(sampleTime));
						const y = Math.round(valueToScreen(value));
						
						if (isFirstPoint) {// Primo punto: sposta il "pennello" (moveTo)
							ctx.moveTo(x, y);
							isFirstPoint = false;
						} else {// Altri punti: traccia linea (lineTo)
							ctx.lineTo(x, y);
						}
						
						count++;
					}
				}
				//console.log("count: " + count);
				
				// Disegno Finale Curva
				ctx.stroke();
				
				// Disegna i cursori e trova i punti più vicini
				if (draggableCursorsActive) {
					['cursor1', 'cursor2'].forEach(cursorId => {
						if (cursors[cursorId].time > 0) {
							const cursorTime = cursors[cursorId].time;
							const segmentX = timeToScreen(cursorTime);
							const color = cursorId === 'cursor1' ? '#dc2626' : '#059669';
							//console.log("cursorTime: "+cursorTime);
							//console.log("segmentX: "+segmentX);
							
							// Trova il punto più vicino al cursore
							const xx = Math.round(segmentX);
							const yy = Math.round(valueToScreen(cursors[cursorId].value));
							//console.log("xx: "+xx);
							//console.log("yy: "+yy);				
							
							// Disegna il segmento verticale del cursore
							ctx.beginPath();
							ctx.strokeStyle = color;
							ctx.lineWidth = 2;
							ctx.moveTo(segmentX, padding);
							ctx.lineTo(segmentX, canvas.height - padding);
							ctx.stroke();
							
							// Disegna il punto sulla curva (se trovato)
							ctx.beginPath();
							ctx.arc(xx, yy, 4, 0, 2 * Math.PI);
							ctx.fillStyle = color;
							ctx.fill();
						}
					});
				}
				
				// Disegna limiti di scroll e soglie
				drawScrollLimits();
				drawThresholds();
			});
		}
//--------------------------------------------------------------------------------------------------------------------------

        function drawGrid() {
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;           // Grid verticale ogni 5ms
            const timeStart = Math.floor(xScale.min / 5000) * 5000;
            for (let t = timeStart; t <= xScale.max; t += 5000) {
                const x = timeToScreen(t);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, canvas.height - padding);
                ctx.stroke();
            }

            // Grid orizzontale ogni 10% del range
            const valueStep = (yScale.max - yScale.min) / 10;
            for (let v = yScale.min; v <= yScale.max; v += valueStep) {
                const y = valueToScreen(v);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width - padding, y);
                ctx.stroke();
            }
        }

        function drawAxes() {
            ctx.beginPath();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();
        }                
        /*-------------------------------------------------------------------------
            CONTROL CALLBACKS SECTION 
          -------------------------------------------------------------------------
        */
       
        function updateTimebase() {
			const oldCenterTime = (xScale.max + xScale.min) / 2;
			timebaseDiv = parseFloat(document.getElementById('timebaseDiv').value);
			console.log("timebaseDiv update: " + timebaseDiv);
			
			const newTimeWindow = timebaseDiv * DIVISIONS_X * 1000000;
			xScale.min = oldCenterTime - newTimeWindow / 2;
			xScale.max = oldCenterTime + newTimeWindow / 2;
			
			console.log("Centro mantenuto a: " + oldCenterTime);
			console.log("Nuova finestra temporale: " + newTimeWindow);
			console.log("Nuovo range: " + xScale.min + " - " + xScale.max);
			
			if (!inputMode) {
				//playRecordWithMetadata();
				drawPlot();
			}
		}
        
        function updateSamplesPerBatch() {
            SAMPLE_RATE = parseInt(document.getElementById('sampleRate').value);
            samplesPerBatch = Math.floor(SAMPLE_RATE / EXPECTED_BATCH_RATE);
            document.getElementById('testSignalInfo').textContent = 
                `Samples per batch: ${samplesPerBatch} (${SAMPLE_RATE}Hz)`;
        }
       
        //function resizeCanvas() {
        //    canvas.width = canvas.offsetWidth;
        //    canvas.height = canvas.offsetHeight;
        //    //if (!isPaused) drawPlot();
        //}

        function toggleStreaming() {
            isStreaming = !isStreaming;
            
            if(isStreaming){
                inputMode = true;
            }else{
                inputMode = false;
            }

            updateConfig("streaming", isStreaming);

            if(isStreaming) {
                batchCount = 0;
                lastBatchTime = null;
                batchIntervals = [];
                batchBuffer = [];
                inputMode = true;
                resetView();
            }
        }

        function resetView() {
            updateSamplesPerBatch();
            batchBuffer.length = 0;
            currBatchIndex = 0;
			resetYScale();
            drawPlotInc();
        }

        function updateBufferSize() {
            bufferDurationSec = parseInt(document.getElementById('bufferDuration').value);
            bufferTimespan = bufferDurationSec * 1000000; // converti in microsecondi
            const avgInterval = batchIntervals.length > 0 ? 
                batchIntervals.reduce((a, b) => a + b, 0) / batchIntervals.length : 5;
            //maxBufferSize = Math.ceil((bufferDurationSec * 1000) / avgInterval);
            maxBufferSize = Math.ceil((bufferDurationSec * 1000) / 5);
            //trimBuffer();
            updateBufferInfo();
        }

        function updateBufferInfo() {
            document.getElementById('bufferInfo').textContent = 
                `${batchBuffer.length}/${maxBufferSize} batches`;
        }

        function trimBuffer() {
            if (batchBuffer.length > maxBufferSize) {
                batchBuffer = batchBuffer.slice(-maxBufferSize);
            }
        }

        function updateBatchStats() {
            if(batchIntervals.length > 0) {
                const avgInterval = batchIntervals.reduce((a, b) => a + b, 0) / batchIntervals.length;
                const actualRate = 1000 / avgInterval;
                const lastBatch = batchBuffer[batchBuffer.length - 1];
                const lastBatchSize = lastBatch ? lastBatch.v.length : 0;

                document.getElementById('batchStats').innerHTML = 
                    `Received Batches: ${batchCount}<br>` +
                    `Avg Interval: ${avgInterval.toFixed(2)} ms<br>` +
                    `Actual Rate: ${actualRate.toFixed(1)} Hz<br>` +
                    `Last Batch Size: ${lastBatchSize} samples`;
            }
        }

        function getDefaultFileName() {
            const now = new Date();
            const prefix = document.getElementById('filePrefix').value;
            return `${prefix}_${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${
                now.getDate().toString().padStart(2,'0')}_${
                now.getHours().toString().padStart(2,'0')}${
                now.getMinutes().toString().padStart(2,'0')}${
                now.getSeconds().toString().padStart(2,'0')}.txt`;
        }

        /*-------------------------------------------------------------------------
            POINT TO SCREEN CONVERSIONS SECTION
          -------------------------------------------------------------------------
        */        
        function timeToScreen(t) {
            return padding + (t - xScale.min) * (canvas.width - 2 * padding) / (xScale.max - xScale.min);
        }

        function valueToScreen(v) {
            return canvas.height - padding - (v - yScale.min) * (canvas.height - 2 * padding) / (yScale.max - yScale.min);
        }

        function screenToTime(x) {
            return xScale.min + (x - padding) * (xScale.max - xScale.min) / (canvas.width - 2 * padding);
        }

        function screenToValue(y) {
            return yScale.min + (canvas.height - padding - y) * (yScale.max - yScale.min) / (canvas.height - 2 * padding);
        }

        document.getElementById('sampleRate').addEventListener('change', function() {
            updateSamplesPerBatch();
            updateConfig('samplerate', this.value);
        });
        /*-------------------------------------------------------------------------
            TEST SIGNAL GENERATION SECTION
          -------------------------------------------------------------------------
        */
        
        /*
        //const initialTime = 1655484153000000; // Timestamp base
        const initialTime = Date.now();
        let count = 1000;
        async function generateTestSignal1() {
            const baseAmplitude = parseFloat(document.getElementById('testAmplitude').value);
            // Timestamp base: 1655484153000000 (62ad7af907880 in hex)
            const batches = [
            // 8 batch iniziali statici
            ...Array(count).fill().map((_, i) => ({
                t: (initialTime + i * 5000),
                v: Array(150).fill().map(() => {
                    const val = Math.floor(baseAmplitude + (Math.random() - 0.5) * 200);
                    return val.toString(16).padStart(6, '0');
                })
            })),
            // Le 5 fasi del salto come prima
            {
                t: (initialTime + count++ * 5000), // Statico pre-stacco
                v: Array(150).fill().map(() => {
                    const val = Math.floor(baseAmplitude + (Math.random() - 0.5) * 200);
                    return val.toString(16).padStart(6, '0');
                })
            },
            {
                t: (initialTime + count++ * 5000), // Stacco
                v: Array(150).fill().map((_, i) => {
                    const progress = i/150;
                    const val = Math.floor(baseAmplitude * (1 + 0.4 * Math.sin(Math.PI * progress)) + (Math.random() - 0.5) * 200);
                    return val.toString(16).padStart(6, '0');
                })
            },
            {
                t: (initialTime + count++ * 5000), // Volo
                v: Array(150).fill().map(() => {
                    const val = Math.floor(Math.random() * 400 - 200);
                    return val.toString(16).padStart(6, '0');
                })
            },
            {
                t: (initialTime + count++ * 5000), // Atterraggio
                v: Array(150).fill().map((_, i) => {
                    const progress = i/150;
                    const val = Math.floor(baseAmplitude * (1.8 * Math.exp(-progress * 5) + 1) + (Math.random() - 0.5) * 200);
                    return val.toString(16).padStart(6, '0');
                })
            },
            {
                t: (initialTime + count++ * 5000), // Ritorno statico
                v: Array(150).fill().map(() => {
                    const val = Math.floor(baseAmplitude + (Math.random() - 0.5) * 200);
                    return val.toString(16).padStart(6, '0');
                })
            }
            ];

            console.log("count: "+count);
            //console.log(JSON.stringify(batches));

            for (batch of batches) {
                processBatch(batch);
                //console.log(JSON.stringify(batch));
                await delay(5);
            }
        }*/        
        
        function generateTestSignal1() {
			const baseAmplitude = parseFloat(document.getElementById('testAmplitude').value);
			const batchSize = Math.floor(SAMPLE_RATE / EXPECTED_BATCH_RATE);
			const samples = [];
			
			const offset = 8; // 40ms = 8 batch da 5ms

			// genero tutti i campioni del batch immediatamente
			for (let i = 0; i < batchSize; i++) {
				// Ricalcola batchProgress e batchPhase per ogni campione
				const batchProgress = Math.floor(testSignalTime / 0.005);
				const batchPhase = (testSignalTime % 0.005) / 0.005;
				
				let value;
				
				if (batchProgress < offset) {
					value = baseAmplitude;
				} else if (batchProgress < 6 + offset) {
					value = baseAmplitude;
				} else if (batchProgress < 12 + offset) {
					const t = (batchProgress - (6 + offset) + batchPhase) / 6;
					value = baseAmplitude * (1 - 0.3 * Math.sin(Math.PI * t));
				} else if (batchProgress < 16 + offset) {
					const t = (batchProgress - (12 + offset) + batchPhase) / 4;
					value = baseAmplitude * (1 + Math.sin(Math.PI * t));
				} else if (batchProgress < 24 + offset) {
					value = 0;
				} else if (batchProgress < 28 + offset) {
					const t = (batchProgress - (24 + offset) + batchPhase) / 4;
					value = baseAmplitude * 2.5 * Math.exp(-t * 2);
				} else if (batchProgress < 36 + offset) {
					const t = (batchProgress - (28 + offset) + batchPhase) / 8;
					value = baseAmplitude * (1 + 0.4 * Math.exp(-t * 3) * Math.cos(2 * Math.PI * t));
				} else {
					testSignalTime = 0;
					return;
				}
				
				if(value > 8388607) value = 8388607;
				value = Math.round(value); // Arrotonda il valore
				value = value & 0xFFFFFF;  // Tronca a 24 bit
				if (value < 0) {
					value += 0x1000000;
				}
				
				let sample = value.toString(16).padStart(6, '0');
				samples.push(sample);
				
				testSignalTime += 1 / SAMPLE_RATE;
			}
			
			const batch = {
				t: Date.now() * 1000,
				v: samples
			};
			
			processBatch(batch);
			
			if (testSignalEnabled1) {
				timers[1] = setTimeout(generateTestSignal1, 1000 / EXPECTED_BATCH_RATE);
			} else {
				clearTimeout(timers[1]);
			}
		}

        function generateTestSignal0() {
            /*
            const currentTime = Date.now();
            if (lastTestSignalUpdate && currentTime - lastTestSignalUpdate < 5) {
                return; // Limit update rate
            }
            lastTestSignalUpdate = currentTime;
            */

            const frequency = parseFloat(document.getElementById('testFrequency').value);
            const baseAmplitude = parseFloat(document.getElementById('testAmplitude').value);
            //const amFrequency = parseFloat(document.getElementById('amFrequency').value);
            
            // Generate a batch of samples
            const batchSize = Math.floor(SAMPLE_RATE / EXPECTED_BATCH_RATE);
            const samples = [];
            
            // genero tutti i campioni del batch immediatamente
            for (let i = 0; i < batchSize; i++) {
                // Calculate amplitude modulation
                //const amplitude = baseAmplitude * (2 + Math.sin(2 * Math.PI * amFrequency * testSignalTime));
                
                // Generate sine wave sample
                let value = Math.round(baseAmplitude * Math.sin(2 * Math.PI * frequency * testSignalTime) + baseAmplitude);

                if(value > 8388607) value = 8388607;

                value = value & 0xFFFFFF;  // Tronca a 24 bit
                if (value < 0) {
                    value += 0x1000000;
                }               
                let sample = value.toString(16).padStart(6, '0');  // Converti in stringa hex di 6 caratteri
               
                // on batch sample queing
                samples.push(sample);
                
                testSignalTime += 1 / SAMPLE_RATE;
            }
            
            // Create batch object
            const batch = {
                t: Date.now() * 1000, // microseconds
                v: samples
            };
            
            // Process batch as if received from WebSocket
            processBatch(batch);
            
            // Schedule next batch if still enabled
            if (testSignalEnabled0) {
                timers[0] = setTimeout(generateTestSignal0, 1000 / EXPECTED_BATCH_RATE);
            }else{
                clearTimeout(timers[0]); 
            }
        }

    
        /*-------------------------------------------------------------------------
            WEBSOCKET CONTROL SECTION
          -------------------------------------------------------------------------
        */
        function onmessageEvent(event) {
            //if(!(adcSignalEnabled || remoteTestEnabled)) return;
            //console.log(`event.data: ${event.data}`);
            // All'arrivo di un batch
			// Evidenzia caratteri speciali
			//console.log('Con caratteri speciali visibili:', JSON.stringify(event.data));
            let batch = JSON.parse(event.data);
            //console.log("first: "+batch.first);
			//console.log("p");
			//counter++;
			if(counter == 100) {
				console.log("counter: "+counter);
                counter = 0;
            }
			if(Object.hasOwn(batch, 'bps')){
				console.log("bps: "+batch.bps);
				return;
			}
            processBatch(batch);
        }

        function processBatch(batch) {   
            if(!inputMode) return; 
			const timestamp = parseInt(batch.t, 16);
            // Aggiungilo al buffer
            batchBuffer.push(batch);
            //console.log("v: "+batch.v);
            // Buffer circolare per registrazione
            if (isRecording) {
                recordBuffer.push(batch);
                if (recordBuffer.length > recordBufferSize) {
                    recordBuffer.shift(); // Buffer circolare
                    console.log("Record buffer full, dropping oldest samples");
                }
            }
    
            // Aggiorna statistiche
            if(lastBatchTime !== null) {
                const interval = (timestamp - lastBatchTime) / 1000;
                batchIntervals.push(interval);
                if(batchIntervals.length > MAX_INTERVALS) {
                    batchIntervals.shift();
                }
            }

            lastBatchTime = timestamp;
            batchCount++;

            // Aggiorna le statistiche a schermo
            if(batchCount % 10 === 0) {
                updateBatchStats();
                updateBufferInfo();
            }
			
            // Stampa a schermo
            if (currBatchIndex === 0) {
                // Inizializzazione finestra temporale
                const firstBatch = batchBuffer[0];
                xScale.min = parseInt(firstBatch.t, 16);
                xScale.max = xScale.min + bufferTimespan;
                console.log(`Finestra temporale: ${xScale.min} - ${xScale.max}`);
                drawPlotInc();
                currBatchIndex++;
            } else if (currBatchIndex < maxBufferSize - 1) {
                //console.log(`currBatchIndex: ${currBatchIndex}, t: ${batchBuffer[currBatchIndex].t}`);
                // Batch intermedi
                drawPlotInc();
                currBatchIndex++;
                //console.log(`Batch corrente: ${currBatchIndex}`);
            } else {
                // Ultimo batch e reset
                drawPlotInc();
                console.log("Reset indice batch");
                currBatchIndex = 0;
				batchBuffer.length = 0;
            }
        }

        function onControlEvent(event) {
            const status = JSON.parse(event.data);
            console.log("Received current status: " + event.data);
            if(status.type === 'status') {
                document.getElementById('currentConfig').innerHTML = 
                    `Sample Rate: ${status.samplerate} Hz<br>` +
                    `EMA Alpha: ${status.alfaema}<br>` +
                    `Streaming: ${status.streaming == "true" ? 'In corso' : 'Bloccato'}<br>`+
                    `ADC Input: ${status.mode == 0 ? 'Attivato' : 'Disattivato'}<br>` +
                    `Remote Test: ${status.mode == 1 ? 'Attivato' : 'Disattivato'}<br>` +
                    `ADC Tone: ${status.mode == 2 ? 'Attivato' : 'Disattivato'}<br>` +
                    `Test frequency: ${status.freq}`;
                
                document.getElementById('streamToggle').innerHTML = status.streaming == "true" ? 'Stop Streaming' : 'Start Streaming';   
                document.getElementById('sampleRate').value = status.samplerate;
                document.getElementById('emaAlpha').value = status.alfaema;
                document.getElementById('enableADCToneL').checked = (status.mode == 3);
                document.getElementById('enableADCToneH').checked = (status.mode == 2);
                document.getElementById('enableADCSignal').checked = (status.mode == 0);
                document.getElementById('testFrequency').value = status.freq;
				
				if(status.streaming == "false"){
					counter = 0;
				}					
				
                SAMPLE_RATE = status.samplerate;
                batchIntervals = [];
                batchBuffer = [];
                handleRadioChange(false);// feedback, non comando...
                resetView();
            }else if(status.type == "event"){
                if (status.overflow > 0) {
                    overflowBox.classList.remove('green');
                    overflowBox.classList.add('red');
                } else {
                    overflowBox.classList.remove('red');
                    overflowBox.classList.add('green');
                }
            }else if('t' in status){
				console.log('Dati al posto di controllo: port swap');
				window.location.reload();
			}
        }
		
		var cntrAttempt = 0;
		var dataAttempt = 0;
		var maxAttempts = 3;

        // ✅ VERSIONE ULTRA-SEMPLIFICATA
		function connectWebSocket(ip, port, path, name, onMessageCallback) {
			let wsh = null;
			let reconnectAttempts = 0;
			let shouldReconnect = true;
			
			function init() {
				wsh = new WebSocket(`ws://${ip}:${port}/${path}`);
				
				wsh.onopen = () => {
					console.log(`✅ ${name} connesso - browser fa ping automatico`);
					reconnectAttempts = 0;
				};
				
				wsh.onclose = () => {
					console.log(`❌ ${name} disconnesso - ping automatico fallito`);
					
					if (shouldReconnect && reconnectAttempts < 10) {
						reconnectAttempts++;
						setTimeout(init, 1000 * reconnectAttempts);
					} else {
						window.location.reload(); // Ultimo resort
					}
				};
				
				wsh.onmessage = onMessageCallback; // ✅ Nessun ping applicativo!
				wsh.onerror = (e) => console.log(`💥 ${name} errore:`, e);
			}
			
			init();
			return wsh;
		}		
		
        function updateConfig(param, value) {
            if(wsControl && wsControl.readyState === WebSocket.OPEN) {
                const config = {};
                
                // Gestione dei diversi tipi di valore
                if (typeof value === 'string') {
                    // Converti in booleano se è "true" o "false"
                    if (value.toLowerCase() === 'true') {
                        config[param] = true;
                    } else if (value.toLowerCase() === 'false') {
                        config[param] = false;
                    } else {
                        // Prova a convertire in numero se non è un booleano
                        config[param] = isNaN(parseFloat(value)) ? value : parseFloat(value);
                    }
                } else {
                    // Mantieni il tipo originale per booleani e numeri
                    config[param] = value;
                }
                
                wsControl.send(JSON.stringify(config));
            } else {
                console.log('WebSocket not connected');
            }
        }

        //wsData = connectWebSocket("192.168.1.167", "81", "ws", "", onmessageEvent);
        //wsControl = connectWebSocket("192.168.1.167", "82", "ws", "", onControlEvent);

        //wsData = connectWebSocket("192.168.10.136", "81", "ws", "", onmessageEvent);
        //wsControl = connectWebSocket("192.168.10.136", "82", "ws", "", onControlEvent);

        //wsData = connectWebSocket("10.12.1.149", "81", "ws", "", onmessageEvent);
        //wsControl = connectWebSocket("10.12.1.149", "82", "ws", "", onControlEvent);

        // Ottiene l'hostname corrente dal browser
        const hostname = window.location.hostname;
        // Usa l'hostname per connettersi ai WebSocket
        wsData = connectWebSocket(hostname, "81", "ws", "", onmessageEvent);
        wsControl = connectWebSocket(hostname, "82", "ws", "", onControlEvent);

        const log = document.getElementById('log');
        const originalConsoleLog = console.log;
        console.log = function(...args) {
            originalConsoleLog.apply(console, args);
            const message = args.join(' ');
            log.innerHTML = message + '<br>' + log.innerHTML;
        };
			/*
			t1: start downward movement
			t2: max downward speed
			t3: max upward speed
			t4: take off
			t5: touch down
			*/
			
//------------------------------------------------JUMP DETECTION--------------------------------------------------------------------------------
		// =====================================================
		// SISTEMA COMPLETO: EMA MULTI-FASE + PULSANTE RICALCOLA
		// =====================================================

		// =====================================================
		// 1. CONTROLLI HTML EMA (come hai già)
		// =====================================================

		function addEMAControlsForJumpPhases() {
			const controlPanel = document.querySelector('.control-panel');
			
			const emaControlsDiv = document.createElement('div');
			emaControlsDiv.className = 'ema-jump-controls';
			emaControlsDiv.innerHTML = `
				<div style="margin: 10px 0; padding: 10px; background: #f0f8ff; border: 1px solid #0ea5e9; border-radius: 4px;">
					<label><strong>EMA per Fasi del Salto:</strong></label>
					
					<div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 10px; margin: 5px 0;">
						<div style="text-align: center;">
							<label style="font-size: 11px; color: #059669; font-weight: bold;">T1: Peso Statico</label>
							<select id="emaAlphaStatic" style="width: 100%;">
								<option value="0.0001">0.0001</option>
								<option value="0.0005">0.0005</option>
								<option value="0.001">0.001</option>
								<option value="0.005">0.005</option>
								<option value="0.01" selected>0.01</option>
								<option value="0.02">0.02</option>
								<option value="0.05">0.05</option>
								<option value="0.1">0.10</option>
								<option value="0.2">0.20</option>
								<option value="0.3">0.30</option>
								<option value="0.3">0.50</option>
								<option value="1">1</option>
							</select>
						</div>
						
						<div style="text-align: center;">
							<label style="font-size: 11px; color: #dc2626; font-weight: bold;">T1: Movimento</label>
							<select id="emaAlphaT1" style="width: 100%;">
								<option value="0.0001">0.0001</option>
								<option value="0.0005">0.0005</option>
								<option value="0.001">0.001</option>
								<option value="0.005">0.005</option>
								<option value="0.01" selected>0.01</option>
								<option value="0.02">0.02</option>
								<option value="0.05">0.05</option>
								<option value="0.1">0.10</option>
								<option value="0.2">0.20</option>
								<option value="0.3">0.30</option>
								<option value="0.3">0.50</option>
								<option value="1">1</option>
							</select>
						</div>
						
						<div style="text-align: center;">
							<label style="font-size: 11px; color: #0369a1; font-weight: bold;">T2-T3: Transizioni</label>
							<select id="emaAlphaT2T3" style="width: 100%;">
								<option value="0.0001">0.0001</option>
								<option value="0.0005">0.0005</option>
								<option value="0.001">0.001</option>
								<option value="0.005">0.005</option>
								<option value="0.01" selected>0.01</option>
								<option value="0.02">0.02</option>
								<option value="0.05">0.05</option>
								<option value="0.1">0.10</option>
								<option value="0.2">0.20</option>
								<option value="0.3">0.30</option>
								<option value="0.3">0.50</option>
								<option value="1">1</option>
							</select>
						</div>
						
						<div style="text-align: center;">
							<label style="font-size: 11px; color: #7c3aed; font-weight: bold;">T4: Stacco</label>
							<select id="emaAlphaT4" style="width: 100%;">
								<option value="0.0001">0.0001</option>
								<option value="0.0005">0.0005</option>
								<option value="0.001">0.001</option>
								<option value="0.005">0.005</option>
								<option value="0.01">0.01</option>
								<option value="0.02">0.02</option>
								<option value="0.05">0.05</option>
								<option value="0.1">0.10</option>
								<option value="0.2">0.20</option>
								<option value="0.3">0.30</option>
								<option value="0.3">0.50</option>
								<option value="1" selected>1</option>
							</select>
						</div>
						
						<div style="text-align: center;">
							<label style="font-size: 11px; color: #ea580c; font-weight: bold;">T5: Atterraggio</label>
							<select id="emaAlphaT5" style="width: 100%;">
								<option value="0.0001">0.0001</option>
								<option value="0.0005">0.0005</option>
								<option value="0.001">0.001</option>
								<option value="0.005">0.005</option>
								<option value="0.01">0.01</option>
								<option value="0.02">0.02</option>
								<option value="0.05">0.05</option>
								<option value="0.1">0.10</option>
								<option value="0.2">0.20</option>
								<option value="0.3">0.30</option>
								<option value="0.3">0.50</option>
								<option value="1" selected>1</option>
							</select>
						</div>
						
						<!-- ✅ NUOVO: Controllo EMA Derivata -->
						<div style="text-align: center;">
							<label style="font-size: 11px; color: #92400e; font-weight: bold;">Derivata Smooth</label>
							<select id="emaAlphaDerivative" style="width: 100%;">
								<option value="0.0001" >0.00001</option>
								<option value="0.0001">0.00005</option>
								<option value="0.0001" selected>0.0001</option>
								<option value="0.0005">0.0005</option>
								<option value="0.001">0.001</option>
								<option value="0.005">0.005</option>
								<option value="0.01">0.01</option>
								<option value="0.02">0.02</option>
								<option value="0.05">0.05</option>
								<option value="0.1">0.10</option>
								<option value="1">1</option>
							</select>
						</div>
					</div>
					
					<div style="margin: 5px 0; font-size: 12px; color: #0369a1;">
						💡 <strong>Consigli:</strong> 
						Derivata: più basso = più smooth (0.0001 ultra-smooth, 0.1 veloce)
					</div>
					
					<div style="margin: 5px 0;">
						<button onclick="resetEMAToFlat()" style="background: #6b7280; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; margin-right: 5px;">Reset to flat</button>
						<button onclick="resetEMAToDefaults()" style="background: #6b7280; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; margin-right: 5px;">Reset Default</button>
						<button onclick="setEMAForHighNoise()" style="background: #dc2626; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; margin-right: 5px;">Alto Rumore</button>
						<button onclick="setEMAForFastJumps()" style="background: #059669; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; margin-right: 5px;">Salti Veloci</button>
						
						<!-- ✅ PULSANTE RICALCOLA INTEGRATO -->
						<button id="recalcThresholdsBtn" onclick="recalculateThresholds()" style="background: #0ea5e9; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-weight: bold;">🔄 Ricalcola Soglie</button>
					</div>
				</div>
			`;
			
			controlPanel.appendChild(emaControlsDiv);
			console.log('✅ Controlli EMA multi-fase + derivata configurabile aggiunti');
		}

		// =====================================================
		// 2. FUNZIONI PRESET EMA (come hai già)
		// =====================================================
		function resetEMAToFlat() {
			document.getElementById('emaAlphaStatic').value = '1';
			document.getElementById('emaAlphaT1').value = '1';
			document.getElementById('emaAlphaT2T3').value = '1';
			document.getElementById('emaAlphaT4').value = '1';
			document.getElementById('emaAlphaT5').value = '1';
			console.log('🔄 EMA reset ai valori di default (derivata=0.0001)');
		}
		
		function resetEMAToDefaults() {
			document.getElementById('emaAlphaStatic').value = '0.05';
			document.getElementById('emaAlphaT1').value = '0.1';
			document.getElementById('emaAlphaT2T3').value = '0.2';
			document.getElementById('emaAlphaT4').value = '0.3';
			document.getElementById('emaAlphaT5').value = '0.4';
			document.getElementById('emaAlphaDerivative').value = '0.0001'; // ✅ Default derivata
			console.log('🔄 EMA reset ai valori di default (derivata=0.0001)');
		}

		function setEMAForHighNoise() {
			document.getElementById('emaAlphaStatic').value = '0.01';
			document.getElementById('emaAlphaT1').value = '0.05';
			document.getElementById('emaAlphaT2T3').value = '0.1';
			document.getElementById('emaAlphaT4').value = '0.2';
			document.getElementById('emaAlphaT5').value = '0.3';
			document.getElementById('emaAlphaDerivative').value = '0.0001'; // ✅ Ultra-smooth per rumore alto
			console.log('🔇 EMA configurato per alto rumore (derivata ultra-smooth)');
		}

		function setEMAForFastJumps() {
			document.getElementById('emaAlphaStatic').value = '0.05';
			document.getElementById('emaAlphaT1').value = '0.2';
			document.getElementById('emaAlphaT2T3').value = '0.3';
			document.getElementById('emaAlphaT4').value = '0.5';
			document.getElementById('emaAlphaT5').value = '0.7';
			document.getElementById('emaAlphaDerivative').value = '0.01'; // ✅ Più veloce per salti rapidi
			console.log('⚡ EMA configurato per salti veloci (derivata più reattiva)');
		}

		// =====================================================
		// 3. FUNZIONE RICALCOLA SOGLIE (NUOVA)
		// =====================================================

		function recalculateThresholds() {
			const btn = document.getElementById('recalcThresholdsBtn');
			
			// Controlla se ci sono dati
			if(!recordBuffer || recordBuffer.length === 0) {
				alert('⚠️ Carica prima un file con i dati del salto!');
				return;
			}
			
			// Feedback visivo
			const originalText = btn.innerHTML;
			btn.innerHTML = '⏳ Ricalcolo...';
			btn.disabled = true;
			btn.style.background = '#f59e0b';
			
			try {							
				// Ridisegna il grafico se siamo in modalità playback
				if(!inputMode && recordBuffer.length > 0) {
					// Analisi del salto e report
					let index = 0;
					let report = {};
					let bIdx = 0;
					let vIdx = 0;
					let t12 = null;
					let sw2 = 0;
					let sd = 0;
					thresholdsList.length = 0;
					do{
						report = analyzeJump(recordBuffer, SAMPLE_RATE, bIdx, vIdx, index, t12, sw2, sd); 		  
						index++;
						console.log('index: '+index);	
						bIdx = report.thresholdTimes.t12bidx;
						vIdx = report.thresholdTimes.t12vidx;
						t5 = report.thresholdTimes.t5;
						t12 = report.thresholdTimes.t12;
						sw2 = report.thresholdTimes.sw2;
						sd = report.thresholdTimes.sd;
						console.log(`next: `+report.thresholdTimes.next);
						if(t5 != null){
							printJumpReport(report);
							thresholdsList.push(report.thresholdTimes);		
						}					
					}while(report.thresholdTimes.next);
					drawPlot();       
					scrollView(0);
				}		
								
				// Ripristina pulsante dopo 2 secondi
				setTimeout(() => {
					btn.innerHTML = originalText;
					btn.style.background = '#0ea5e9';
					btn.disabled = false;
				}, 2000);
				
			} catch(error) {
				console.error('❌ Errore durante il ricalcolo:', error);
				
				// Feedback errore
				btn.innerHTML = '❌ Errore';
				btn.style.background = '#dc2626';
				
				setTimeout(() => {
					btn.innerHTML = originalText;
					btn.style.background = '#0ea5e9';
					btn.disabled = false;
				}, 2000);
			}
		}

		// =====================================================
		// 4. ALGORITMO DETECTJUMPTHRESHOLDS
		// =====================================================
		function detectJumpThresholds(recordBuffer, sampleRate, bIdx, vIdx, t12, sw2, sd) {	
			console.log('detectJumpThresholds-bIdx: '+bIdx);
			console.log('detectJumpThresholds-vIdx: '+vIdx);
			console.log('t12.time: '+((t12!=null)?t12.time:null));	

			let result = {t1: (t12 != null)? {time: t12.time, bidx: t12.bidx, vidx: t12.vidx}: null, t2: null, t3: null, t4: null, t5: null, t6: null, t7: null, t12: null, sw1: sw2, sw2: null, sd: sd, t12bidx: null, t12vidx: null, next: false};
			let minDerivative = Infinity;
			let maxDerivative = -Infinity;
			let precBatchTime;
			let currBatchTime;  
			let batchLen;
			let lastForce = null;
			let force = 0;
			let staticCount = 0;
			let diffWeight = 0;
			let diffWeightSD = 0;
			let staticWeights = [];	
			let derivativeWindow = [];
			const windowSize = 200 // Ultimi 100 campioni
			let minForce = +Infinity;
			let sdValue = 0;
			let sdCount = 0;
			let staticVariance = 0;
			let maxDiff = -Infinity;
			let minDiff = Infinity;
			let quietStandingExitCounter = 0;
			// Inizializza tutti gli EMA con il primo valore
			const firstRawValue = calculateValue(recordBuffer[bIdx].v[vIdx]);
			const firstTime =  parseInt(recordBuffer[bIdx].t, 16) / 1000000;// t in sec
			let currentMax = firstRawValue;
			let currentMin = firstRawValue;
			//let maxIndex = 0;
			//let minIndex = 0;
			let maxValidated = false;
			let minValidated = false;
			let amplitude = Infinity;
						
			function calculateMeans(){
				staticCount++;
				
				// ✅ WELFORD'S algorithm
				const oldMean = staticWeight;
				const delta = force - oldMean;
				staticWeight = oldMean + delta / staticCount;
				const delta2 = force - staticWeight;
				
				if(delta2 > maxDiff){
					maxDiff = delta2;
				}else if(delta2 < minDiff){
					minDiff = delta2;
				}
				staticVariance += delta * delta2;
				
				if(staticCount > 10) {
					staticWeightSD = Math.sqrt(staticVariance / (staticCount - 1));
				}
			}
			
			function calculatePeaks(c) {
				ok = false;
				
				let ref = staticWeight;
				// ✅ Aggiorna estremi delle deviazioni per oscillazioni
				if(force - ref > currentMax){
					currentMax = force - ref;
					maxValidated = false;
				}
				
				if(force - ref < currentMin){
					currentMin = force - ref;
					minValidated = false;
				}
				
				// Validazione MASSIMO: attraversamento media mobile scendendo
				if (!maxValidated && c) {
					maxValidated = true;
					amplitude = Math.abs(currentMax - currentMin);
					console.log('calculateMeans -> amplitude MASSIMO: '+amplitude+', currentMax: '+currentMax+', currentMin: '+currentMin+', ref: '+ref);
					
					// Reset per cercare prossimo minimo
					currentMin = force - ref;
					minValidated = false;
					ok = true;
				}
				
				// Validazione MINIMO: attraversamento media mobile salendo
				if (!minValidated && c) {
					minValidated = true;
					amplitude = Math.abs(currentMax - currentMin);
					console.log('calculateMeans -> amplitude MINIMO: '+amplitude+', currentMax: '+currentMax+', currentMin: '+currentMin+', ref: '+ref);
					
					// Reset per cercare prossimo massimo
					currentMax = force - ref;
					maxValidated = false;
					ok = true;
				}
				return ok;
			}
			
			function calculatePeaks1(ref) {
				// ✅ Aggiorna estremi delle deviazioni per oscillazioni
				if(force - ref > currentMax){
					currentMax = force - ref;
					maxValidated = false;
				}
				
				if(force - ref < currentMin){
					currentMin = force - ref;
					minValidated = false;
				}
				
				// Validazione MASSIMO: attraversamento media mobile scendendo
				if (!maxValidated && currentMax > force - ref) {
					if (force - ref <= 0) {
						maxValidated = true;
						amplitude = Math.abs(currentMax - currentMin);
						console.log('calculateMeans -> amplitude MASSIMO: '+amplitude+', currentMax: '+currentMax+', currentMin: '+currentMin+', ref: '+ref);
						
						// Reset per cercare prossimo minimo
						currentMin = force - ref;
						minValidated = false;
					}	
				}
				
				// Validazione MINIMO: attraversamento media mobile salendo
				if (!minValidated && currentMin < force - ref) {
					if (force - ref >= 0) {
						minValidated = true;
						amplitude = Math.abs(currentMax - currentMin);
						console.log('calculateMeans -> amplitude MINIMO: '+amplitude+', currentMax: '+currentMax+', currentMin: '+currentMin+', ref: '+ref);
						
						// Reset per cercare prossimo massimo
						currentMax = force - ref;
						maxValidated = false;
					}
				}
			}
			
			function isPeak() {
				//console.log('getPeakAmp -> amplitude: '+amplitude);
				return minValidated || maxValidated;
			}
			
			function getPeakAmp() {
				//console.log('getPeakAmp -> amplitude: '+amplitude);
				return amplitude;
			}
			
			function getMaxDelta() {
				return maxDiff;
			}
			
			function getMinDelta() {
				return minDiff;
			}
			
			function getSD() {
				//console.log('getSD -> staticWeightSD: '+staticWeightSD);
				return staticWeightSD;
			}
			
			function getMean() {
				return staticWeight;
			}
			
			function getSDMean() {
				//console.log('getSDMean -> sdValue: '+sdValue);
				return sdValue;				
			}
			
			function getLocalSD() {
				//console.log('getSDMean -> sdValue: '+sdValue);
				return staticWeightSD;				
			}
			
			function calculateSDMean() {
				sdCount++;
				sdValue = sdValue + (staticWeightSD - sdValue) / sdCount; // calcolo media della varianza su più salti
				//console.log('calculateSDMean -> sdValue: '+sdValue);
				result.sd = sdValue;
				return sdValue;
			}
			
			function initPeaks(){
				currentMax = -Infinity;
				currentMin = Infinity;
				//let maxIndex = 0;
				//let minIndex = 0;
				maxValidated = false;
				minValidated = false;
				amplitude = Infinity;
			}
			
			function initRunningMeans(force, deviation) {
				staticWeight = force;
				staticWeightSD = deviation;
				//sdValue = deviation;
				staticCount = 0;
				console.log('initRunningMeans ->initForce: '+force+' initDev: '+deviation);
				staticVariance = 0;  // Per Welford's algorithm
				maxDiff = -Infinity;
				minDiff = Infinity;
			}
			
			function initSDMean(deviation) {
				sdValue = deviation;
			}
			
			function updateRollingWindow(derivative) {
				derivativeWindow.push(Math.abs(derivative));
				if(derivativeWindow.length > windowSize) {
					derivativeWindow.shift(); // Rimuove il più vecchio
				}
			} 
			
			function getRollingPercentile(percentile) {
				if(derivativeWindow.length < 20) return 1000; // Fallback iniziale
				const sorted = derivativeWindow.slice().sort((a,b) => a-b);
				return sorted[Math.floor(sorted.length * percentile / 100)];
			}
					
			// ✅ LEGGI TUTTI I VALORI EMA DAI MENU (INCLUSA DERIVATA)
			const emaAlphas = {
				static: parseFloat(document.getElementById('emaAlphaStatic')?.value || 0.05),
				t1: parseFloat(document.getElementById('emaAlphaT1')?.value || 0.1),
				t2t3: parseFloat(document.getElementById('emaAlphaT2T3')?.value || 0.2),
				t4: parseFloat(document.getElementById('emaAlphaT4')?.value || 0.3),
				t5: parseFloat(document.getElementById('emaAlphaT5')?.value || 0.4),
				// ✅ EMA DERIVATA CONFIGURABILE DAL MENU
				derivative: parseFloat(document.getElementById('emaAlphaDerivative')?.value || 0.0001)
			};
			
			let betaRawEMA = 0.25;
			let betaRawRun = 0.25;
			let betaEmaRun = 0.95;
			
			console.log(`🎛️ EMA multi-fase: Statico=${emaAlphas.static}, T1=${emaAlphas.t1}, T2-T3=${emaAlphas.t2t3}, T4=${emaAlphas.t4}, T5=${emaAlphas.t5}, Derivata=${emaAlphas.derivative}`);
			
			// CALCOLO PESO STATICO (con EMA dedicato)
			
			let staticEmaValue = null;
			
			
			// INIZIALIZZAZIONE PRINCIPALE
			const dt0 = 1/sampleRate;
			precBatchTime = parseInt(recordBuffer[0].t, 16) / 1000000 - dt0;
			
			// EMA values separati per ogni fase
			let emaValues = {
				current: null,
				t1: null,      
				t2t3: null,
				t4: null,
				t5: null,
				t6: null,
				dev1: null,
				dev2: null
			};
			
			// ✅ EMA per la derivata (configurabile)
			let derivativeEma = null;
			let staticDerivativeEma = null;
			emaValues.t1 = firstRawValue;
			emaValues.t2t3 = firstRawValue;
			emaValues.t4 = firstRawValue;
			emaValues.t5 = firstRawValue;
			emaValues.current = firstRawValue;
			let staticWeight = firstRawValue;
			let staticWeightSD = 0;
			initRunningMeans(firstRawValue, sd);// si parte da Fbody
			initSDMean(sd);
			
			filterh.predict();
			lastForce = filterh.update(emaValues.current);
			batchLen = recordBuffer[0].v.length;			
			// ANALISI PRINCIPALE CON EMA DINAMICO PER FASE
			let sampleIndex = 0;
			staticDerivativeAlpha = 0.0001;
			staticWeights.length = 0;
			let esci = false;
			let cont = 0;
			let single = true;
			for(let batchIdx = bIdx; batchIdx < recordBuffer.length && !esci; batchIdx++) {
				const batch = recordBuffer[batchIdx];
				currBatchTime = parseInt(recordBuffer[batchIdx].t, 16) / 1000000;// t in sec
				const dt = (currBatchTime - precBatchTime) / batchLen;
				// Determina gli indici di inizio e fine per questo batch
                let startIdx = (batchIdx === bIdx) ? vIdx : 0;
				let k = 1;
				for(let i = startIdx; i < batch.v.length && !esci; i++) {					
					const rawValue = calculateValue(batch.v[i]);
					
					// AGGIORNA TUTTI GLI EMA CONTEMPORANEAMENTE
					emaValues.t1 = emaAlphas.t1 * rawValue + (1 - emaAlphas.t1) * emaValues.t1;
					emaValues.t2t3 = emaAlphas.t2t3 * rawValue + (1 - emaAlphas.t2t3) * emaValues.t2t3;
					emaValues.t4 = emaAlphas.t4 * rawValue + (1 - emaAlphas.t4) * emaValues.t4;
					emaValues.t5 = emaAlphas.t5 * rawValue + (1 - emaAlphas.t5) * emaValues.t5;
					
					// SELEZIONE EMA IN BASE ALLA FASE CORRENTE
					let selectedEmaValue;
					if(result.t1 === null) {
						selectedEmaValue = emaValues.t1;        // Fase T1: rilevamento movimento
					} else if(result.t2 === null || result.t3 === null) {
						selectedEmaValue = emaValues.t2t3;      // Fase T2-T3: transizioni peso
					} else if(result.t4 === null) {
						selectedEmaValue = emaValues.t4;        // Fase T4: stacco
					} else if(result.t5 === null) {
						selectedEmaValue = emaValues.t5;        // Fase T5: atterraggio
					} else {
						selectedEmaValue = emaValues.t2t3;      // Default: transizioni
						//selectedEmaValue = rawValue;  
					}					
					
					//filterh.predict();
					//force = filterh.update(selectedEmaValue);
					force = selectedEmaValue;
					
					const currentTime = currBatchTime + (i * dt);
					
					// ✅ CALCOLA DERIVATA RAW
					const rawDerivative = (force - lastForce) / dt;
					
					// ✅ APPLICA EMA CONFIGURABILE ALLA DERIVATA
					let smoothedDerivative;
					if(derivativeEma === null) {
						derivativeEma = rawDerivative;  // Inizializza con la prima derivata
						smoothedDerivative = rawDerivative;
					} else {
						derivativeEma = emaAlphas.derivative * rawDerivative + (1 - emaAlphas.derivative) * derivativeEma;
						smoothedDerivative = derivativeEma;
					}
					updateRollingWindow(smoothedDerivative);
					
					// ✅ DEBUG: Confronto derivata raw vs smoothed (ogni 2000 campioni)
					if(sampleIndex % 2000 === 0) {
						//console.log(`📈 Derivata #${sampleIndex}: Raw=${rawDerivative.toFixed(0)}, Smoothed=${smoothedDerivative.toFixed(2)}, Alpha=${emaAlphas.derivative}`);
						//console.log('i: '+i+', esci: '+esci);
					}
					
					/*
					t1: start downward movement
					t2: max downward speed
					t3: max upward speed
					t4: take off
					t5: touch down
					t6: end landing
					*/
					
					// ✅ USA DERIVATA SMOOTHED CONFIGURABILE NELLE SOGLIE
					//t1: start downward movement
					if(result.t1 === null) {
						//console.log(`time: ${1}`);
						//if(smoothedDerivative < -200 && force < staticWeight && lastForce >= staticWeight) {
						//if( Math.abs(force) < 0.95 * staticWeight && smoothedDerivative < 0) {
						//To identify the start of the countermovement after quiet standing, the first
						//value that exceeded either the maximum + one SD or the
						//minimum – one SD was identified.
						if(isPeak() && currentTime - firstTime > 1.4 && getPeakAmp() < 2*getSD()){
						//if( Math.abs(force) < 0.95 * staticWeight && Math.abs(force-getMean())>getSD()*5 ) {
							result.sd = calculateSDMean();
							console.log('calculateSDMean -> sdValue: '+result.sd);
							console.log(`✅ getMeans=${staticWeight}, getMinDelta=${getMinDelta()},  getMaxDelta=${ getMaxDelta()}, getLocalSD()=${getLocalSD()}`);
							result.t1 = {time:currentTime, bidx: batchIdx, vidx: i, sd: getSDMean()}; //time backward							
							console.log(`✅ T1 trovato Force: ${force}, (EMA α=${emaAlphas.t1}, derivata α=${emaAlphas.derivative}): time=${currentTime.toFixed(3)}, force= derivata_raw=${rawDerivative.toFixed(0)}, derivata_smooth=${smoothedDerivative.toFixed(2)}`);					
							result.sw1 = staticWeights[staticWeights.length-1];// scarta fStatico degli ultimi 12 campioni
							staticWeights.length = 0;
							console.log(`📊 Peso statico 1 (EMA α=${emaAlphas.static}): ${staticWeight.toFixed(0)} da ${staticCount} campioni`);
							
							let sample = goForwardUntilOutNorm(result.t1.bidx, result.t1.vidx, 0.1*getMinDelta() - getLocalSD(), 0.1*getMaxDelta() + getLocalSD(), result.sw1, batchLen);
							console.log(`✅ T1 forward prima time=${result.t1.time.toFixed(3)}, getLocalSD=${getLocalSD()}, bidx=${result.t1.bidx.toFixed(3)}, vidx=${result.t1.vidx.toFixed(3)}`);
							console.log(`✅ T1 forward dopo time=${sample.time.toFixed(3)}, getLocalSD=${getLocalSD()}, bidx=${sample.bidx.toFixed(3)}, vidx=${sample.vidx.toFixed(3)}`);							
							result.t1 = {time:sample.time, bidx: sample.bidx, vidx: sample.vidx};
						}else{
							calculateMeans();
							calculatePeaks(Math.abs(smoothedDerivative) < 0.15);
							//console.log(`time: ${currentTime}, force: ${force}, mean: ${getMean()}, SD: ${getSDMean()}, getMinDelta=${getMinDelta()}, getMaxDelta=${ getMaxDelta()}, getLocalSD()=${getLocalSD()}`);
						}	
					}						

					//t2: max downward speed
					//if(result.t2 == null && result.t1 !== null && smoothedDerivative > 0  && Math.abs(force-getMean())<getSDMean()) {
					if(result.t2 == null && result.t1 !== null && Math.abs(force) < 0.95 * result.sw1 &&  smoothedDerivative > getRollingPercentile(95) ) {
						console.log(`result.sw1: ${result.sw1}, force: ${force}`);
						result.t2 = {time:currentTime, bidx: batchIdx, vidx: i};
						console.log(`✅ T2 trovato Force: ${force}, (sdmean: ${getSDMean()}): time=${currentTime.toFixed(3)}, derivata_smooth=${smoothedDerivative.toFixed(2)}`);
					}else{
						//console.log(`result.sw1: ${result.sw1}, force: ${force}`);
					}
					
					// t3: max upward speed
					if(result.t3 == null && result.t2 !== null && smoothedDerivative < -getRollingPercentile(20) && force < result.sw1+5*getSDMean() && lastForce >= result.sw1-5*getSDMean()) {
						console.log(`time: ${3}`);
						result.t3 = {time:currentTime, bidx: batchIdx, vidx: i};
						console.log(`✅ T3 trovato Force: ${force}, (derivata α=${emaAlphas.derivative}): time=${currentTime.toFixed(3)}, derivata_smooth=${smoothedDerivative.toFixed(2)}`);
					}
					
					// t4: take off
					//if(result.t4 == null && result.t3 !== null && force < 0.05 && smoothedDerivative < -100) {
					//if(result.t4 == null && force < 0 && lastForce > 0) {
					if(result.t4 == null && result.t3 !== null && force < 0.05) {
						console.log(`time: ${4}`);
						console.log(`Force: ${force}, lastForce: ${lastForce}`);
						result.t4 = {time:currentTime, bidx: batchIdx, vidx: i};
						console.log(`✅ T4 trovato Force: ${force}, derivata α=${emaAlphas.derivative}): time=${currentTime.toFixed(3)}, derivata_smooth=${smoothedDerivative.toFixed(2)}`);
					}
					
					// t5: touch down
					if(result.t5 == null && result.t4 !== null && force > result.sw1 *2/3) {
						console.log(`time: ${5}`);
						console.log(`avanti: ${currentTime}, Force: ${force}, result.sw1 *2/3: ${result.sw1 *2/3}, getSDMean() ${getSDMean()}, batchIdx: ${batchIdx}, vidx: ${i}`);
						const sample = goBackUntilLower(batchIdx, i, 0.05, batchLen);
						console.log(`indietro: ${sample.time}, SD: ${getSDMean()}, Force ${sample.value}, batchIdx: ${sample.bidx}, vidx: ${sample.vidx}`);
						result.t5 = {time:sample.time, bidx: sample.bidx, vidx: sample.vidx};
						initPeaks();
						console.log(`✅ T5 trovato Force: ${sample.value}, (derivata α=${emaAlphas.derivative}): time=${currentTime.toFixed(3)}, derivata_smooth=${smoothedDerivative.toFixed(2)}`);
					}
					
					// t6: end landing
					//if(result.t6 == null && result.t5 !== null && Math.abs(force) < 1.5 * result.sw1 && smoothedDerivative < 0.05 && smoothedDerivative > -0.05) {
					// result.sw1 è misurato sul takeoff e non è uguale a quello sul landing per cui funziona meglio la derivata rispetto alla DS
					//if(result.t6 == null && result.t5 !== null && Math.abs(force - staticWeight) < getSDMean() ) {	
					if(result.t6 == null && result.t5 !== null) {// quite standing start detection	
					//console.log(`time: ${6}`);
					//if(result.t6 == null && result.t5 !== null && Math.abs(force - result.sw1) < 20*getSDMean()  && Math.abs(force - result.sw1) > 0.01*getSDMean()) {	
						//console.log(`getPeakAmp() t6: ${getPeakAmp()}`);
						//console.log(`getSDMean() t6: ${0.4*getSDMean()}`);
						if(isPeak() && getPeakAmp() < 0.4*getSDMean()) {// position condition	
							result.t6 = {time:currentTime, bidx: batchIdx, vidx: i};
							//staticWeight = 0;
							console.log(`✅ T6 trovato Force: ${force}, (derivata α=${emaAlphas.derivative}): time=${currentTime.toFixed(3)}, derivata_smooth=${smoothedDerivative.toFixed(2)}`);
							initRunningMeans(force, getSDMean());
							quietStandingExitCounter = 0;
						}else{
							calculateMeans();
							if(calculatePeaks(Math.abs(smoothedDerivative) < 0.15)){// velocity condition
								initRunningMeans(force - staticWeight, getPeakAmp());// si parte da f - Fbody
							}
							//console.log(`getSD: ${getSD()}`);
						}
					}
					
					if(result.t7 == null && result.t6 !== null) {// quite standing end detection
						//console.log(` force - staticWeight t7: ${force - staticWeight}`);
						//console.log(` getSD() t7: ${getSD()}`);
						if(Math.abs(force - staticWeight) > 0.2*getSDMean() || smoothedDerivative > 0.15) {
							//console.log(` getSD() t7: ${0.4*getSD()}`);
							quietStandingExitCounter++;
							
							if(quietStandingExitCounter >= 5) { // 5 campioni consecutivi
								const quietDuration = currentTime - result.t6.time;
								if(quietDuration >= 0.45) { // Almeno 500ms di quiet standing
									//calculateSDMean();
									result.t7 = {time:currentTime, bidx: batchIdx, vidx: i};
									result.sw2 = staticWeights[staticWeights.length -1];
									//result.sd = calculateSDMean();
									console.log('calculateSDMean -> sdValue: '+result.sd);
									//result.sd = calculateSDMean();
									console.log(`✅ T7 trovato time=${result.t7.time.toFixed(3)}, getLocalSD=${getLocalSD()}, bidx=${result.t7.bidx.toFixed(3)}, vidx=${result.t7.vidx.toFixed(3)}, derivata_smooth=${smoothedDerivative.toFixed(2)}`);
								} else {
									// Troppo breve, continua a cercare
									//console.log(`⚠️ Quiet standing troppo breve (${quietDuration.toFixed(3)}s), continuo...`);
									quietStandingExitCounter = 0;
									calculateMeans();
								}								
							}else{
								calculateMeans();
							}
						} else {
							quietStandingExitCounter = 0; // Reset se torna in range
							calculateMeans();
						}
					}
					
					if(result.t12 === null && result.t7 !== null) {
						//console.log(`time: ${12}`);
						if(force < result.sw2*2/3 || (force >= result.sw2*2/3) && currentTime - result.t7.time > 0.7) {
							//if( Math.abs(force) > staticWeight + 2*emaValues.devEmaRun) {
							console.log('currentTime - result.t7.time: '+ (currentTime - result.t7.time));
							console.log('force: '+force);console.log('result.sw2: '+result.sw2);console.log('is_a: '+(force < result.sw2*2/3));
							if(force < result.sw2*2/3){
								//result.sd = calculateSDMean();
								//result.t12 = {time:currentTime - 0.005*40, bidx: batchIdx - 40, vidx: 0, sd: result.sd};
								result.t12 = {time:currentTime, bidx: batchIdx, vidx: 0, sd: result.sd};								
								console.log(`✅ T12 trovato Force: ${force}, (EMA α=${emaAlphas.t1}, derivata α=${emaAlphas.derivative}): time=${result.t12.time.toFixed(3)}, force= derivata_raw=${rawDerivative.toFixed(0)}, derivata_smooth=${smoothedDerivative.toFixed(2)}`);						
								//result.sw2 = staticWeights[staticWeights.length -1];
								console.log('fStatico2-12: '+result.sw2);
								result.t12bidx = batchIdx;
								result.t12vidx = 0;
								// raffinamento t12 backward
								console.log(`📊 Peso statico 2 (EMA α=${emaAlphas.static}): ${staticWeight.toFixed(0)} da ${staticCount} campioni`);
								let sample = goBackUntilUpperNorm(result.t12.bidx, result.t12.vidx, 0, result.sw2, batchLen);
								console.log(`✅ T12 prima time=${result.t12.time.toFixed(3)}, getSDMean=${getSDMean()}, bidx=${result.t12.bidx.toFixed(3)}, vidx=${result.t12.vidx.toFixed(3)}`);
								console.log(`backstep: ${(result.t12bidx - sample.bidx) - 1}`);
								//result.sw2 = staticWeights[staticWeights.length - (result.t12bidx - sample.bidx) - 1];
								//console.log(`backstep sw2: ${result.sw2}`);
								result.t12 = {time:sample.time, bidx: sample.bidx, vidx: sample.vidx};
								console.log(`✅ T12 dopo time=${result.t12.time.toFixed(3)}, getSDMean=${getSDMean()}, bidx=${result.t12.bidx.toFixed(3)}, vidx=${result.t12.vidx.toFixed(3)}`);
								result.next = true;
								console.log('result.next_a: '+result.next);
							}else{
								//result.sd = calculateSDMean();
								//result.sd = getLocalSD();
								result.t12 = {time:currentTime, bidx: batchIdx, vidx: i, sd: result.sd};		
								console.log(`✅ T12 B Force: ${force}, (EMA α=${emaAlphas.t1}, derivata α=${emaAlphas.derivative}): time=${result.t12.time.toFixed(3)}, force= derivata_raw=${rawDerivative.toFixed(0)}, derivata_smooth=${smoothedDerivative.toFixed(2)}`);						
								//result.sw2 = staticWeights[staticWeights.length-1];
								console.log('fStatico2: '+result.sw2);
								console.log('getLocalSD(): '+getLocalSD());
								//staticWeight = force;
								result.t12bidx = null;
								result.t12vidx = null;
								result.next = false;
								console.log('result.next_b: '+result.next);
							}
							// inizio
							// minimum – one SD was obtained.)
							/*console.log(`✅ getMinDelta=${getMinDelta()},  getMaxDelta=${ getMaxDelta()}, getLocalSD()=${getLocalSD()}`);
							sample = goBackUntilOutNorm(result.t6.bidx, result.t6.vidx, getMinDelta() - getLocalSD(), getMaxDelta() + getLocalSD(), result.sw2, batchLen);
							console.log(`✅ T6back prima time=${result.t6.time.toFixed(3)}, getLocalSD=${getLocalSD()}, bidx=${result.t6.bidx.toFixed(3)}, vidx=${result.t6.vidx.toFixed(3)}`);
							console.log(`✅ T6back dopo time=${sample.time.toFixed(3)}, getLocalSD=${getLocalSD()}, bidx=${sample.bidx.toFixed(3)}, vidx=${sample.vidx.toFixed(3)}`);
							// raffinamento t6 forward (Then, moving forward, the last point that exceeded 0 N (positive or negative) was identified as the end of the landing phase)
							console.log(`✅ T6forward prima time=${sample.time.toFixed(3)}, getLocalSD=${getLocalSD()}, bidx=${sample.bidx.toFixed(3)}, vidx=${sample.vidx.toFixed(3)}`);
							sample = goForwardUntilEqualNorm(sample.bidx, sample.vidx, 0, result.sw2, batchLen);
							sample = getPrecValue(sample.bidx, sample.vidx, batchLen);
							result.t6 = {time:sample.time, bidx: sample.bidx, vidx: sample.vidx};
							console.log(`✅ T6forward dopo time=${result.t6.time.toFixed(3)}, getLocalSD=${getLocalSD()}, bidx=${result.t6.bidx.toFixed(3)}, vidx=${result.t6.vidx.toFixed(3)}`);
							*/// fine
							// metodo alternativo
							/*const sample = goBackUntilUpperNorm(result.t6.bidx, result.t6.vidx, 0.5*result.sd, result.sw2, batchLen);
							console.log(`✅ T6 prima time=${result.t6.time.toFixed(3)}, getSDMean=${getSDMean()}, bidx=${result.t6.bidx.toFixed(3)}, vidx=${result.t6.vidx.toFixed(3)}`);
							result.t6 = {time:sample.time, bidx: sample.bidx, vidx: sample.vidx};
							console.log(`✅ T6 prima time=${result.t6.time.toFixed(3)}, getSDMean=${getSDMean()}, bidx=${result.t6.bidx.toFixed(3)}, vidx=${result.t6.vidx.toFixed(3)}`);
							*/// fine metodo alternativo
							staticWeights.length = 0;
							esci = true;
						}else{
							//console.log('devEmaRun: '+ (-Math.abs(force) + staticWeight + 4*emaValues.devEmaRun));
							//calculateMeans();
						}	
					}						
					
					lastForce = force;
					sampleIndex++;
				}
				precBatchTime = currBatchTime;
				staticWeights.push(staticWeight);// salva fStatico ad ogni campione
			}
			
			console.log(`next: ${result.next}`);
			//console.log(`📊 Derivata finale smoothed (α=${emaAlphas.derivative}): ${derivativeEma?.toFixed(2)}`);
			return result;
		}	
		
		function getNextValue(bidx, vidx, len) {
			//console.log('getPrecValue -> bidx: '+bidx+', vidx: '+vidx);
			let vidxNew = (vidx + 1) % len;// incremento modulo len
			if (vidxNew === 0) {
				if(bidx + 1 < recordBuffer.length){
					bidx++; // se siamo prima dell'ultimo batch, lo incrementiamo
					vidx = vidxNew;
				}
			}else{
				vidx = vidxNew;
			}
			
			const batch = recordBuffer[bidx];
			const value = calculateValue(batch.v[vidx]);
			//console.log('value: '+value);
			const actualTime = parseInt(batch.t, 16) + (vidx * 0.005/len*1000000);
			//console.log('actualTime: '+actualTime+', bidx: '+bidx+', vidx: '+vidx);
			
			return {value: value, bidx: bidx, vidx: vidx, time: actualTime/1000000};	
		}	
		
		function goForwardUntilEqualNorm(bidx, vidx, val, offset = 0, len, nmax = 50000){
			let sample = {bidx: bidx, vidx: vidx};
			sample = getNextValue(sample.bidx, sample.vidx, len);
			let prec =  sample.value;
			for(let k=0; k<nmax; k++){
				sample = getNextValue(sample.bidx, sample.vidx, len);
				//console.log(`sample.value - offset: ${sample.value - offset}, val: ${val}`);
				if(prec - offset > val && sample.value - offset < val){
					break;
				}else if(prec - offset < val && sample.value - offset > val){
					break;
				}
				prec = sample.value;
			}
			return sample;
		}
			
		function goForwardUntilOutNorm(bidx, vidx, lower, upper, offset = 0, len, nmax = 50000){
			let sample = {bidx: bidx, vidx: vidx};
			for(let k=0; k<nmax; k++){
				sample = getNextValue(sample.bidx, sample.vidx, len);
				//console.log(`sample.value - offset: ${sample.value - offset}, min: ${lower}, max: ${upper}`);
				if(sample.value - offset < lower || sample.value - offset > upper){
					break;
				}
			}
			return sample;
		}

		function getPrecValue(bidx, vidx, len) {
			//console.log('getPrecValue -> bidx: '+bidx+', vidx: '+vidx);
			let stop = false;
			if (vidx === 0) {
				if(bidx > 0){
					bidx--; // se siamo a 0 e torniamo indietro, scaliamo il batch
				}else{
					stop = true;
				}
			}
			if(!stop){
				vidx = (vidx - 1 + len) % len;// decremento modulo len
			}
			
			const batch = recordBuffer[bidx];
			const value = calculateValue(batch.v[vidx]);
			//console.log('value: '+value);
			const actualTime = parseInt(batch.t, 16) + (vidx * 0.005/len*1000000);
			//console.log('actualTime: '+actualTime+', bidx: '+bidx+', vidx: '+vidx);
			
			return {value: value, bidx: bidx, vidx: vidx, time: actualTime/1000000};	
		}	

		function goBackUntilLower(bidx, vidx, val, len, nmax = 50000){
			let sample = {bidx: bidx, vidx: vidx};
			for(let k=0; k<nmax; k++){
				sample = getPrecValue(sample.bidx, sample.vidx, len);
				//console.log(`giro prima: ${sample.value}, cont: ${k}`);
				if(sample.value < val){
					break;
				}
			}
			return sample;
		}
		
		function goBackUntilLowerNormUnsigned(bidx, vidx, val, offset = 0, len, nmax = 50000){
			let sample = {bidx: bidx, vidx: vidx};
			for(let k=0; k<nmax; k++){
				sample = getPrecValue(sample.bidx, sample.vidx, len);
				console.log(`sample.value - offset: ${sample.value - offset}, val: ${val}`);
				if(Math.abs(sample.value - offset) < val){
					break;
				}
			}
			return sample;
		}
		
		function goBackUntilLowerNorm(bidx, vidx, val, offset = 0, len, nmax = 50000){
			let sample = {bidx: bidx, vidx: vidx};
			for(let k=0; k<nmax; k++){
				sample = getPrecValue(sample.bidx, sample.vidx, len);
				console.log(`sample.value - offset: ${sample.value - offset}, val: ${val}`);
				if(sample.value - offset < val){
					break;
				}
			}
			return sample;
		}
		
		function goBackUntilLowerEqualNorm(bidx, vidx, val, offset = 0, len, nmax = 50000){
			let sample = {bidx: bidx, vidx: vidx};
			for(let k=0; k<nmax; k++){
				sample = getPrecValue(sample.bidx, sample.vidx, len);
				console.log(`sample.value - offset: ${sample.value - offset}, val: ${val}`);
				if(sample.value - offset <= val){
					break;
				}
			}
			return sample;
		}
		
		function goBackUntilUpper(bidx, vidx, val, len, nmax = 50000){
			let sample = {bidx: bidx, vidx: vidx};
			for(let k=0; k<nmax; k++){
				sample = getPrecValue(sample.bidx, sample.vidx, len);
				//console.log(`giro prima: ${sample.value}, cont: ${k}`);
				if(sample.value > val){
					break;
				}
			}
			return sample;
		}
		
		function goBackUntilUpperNormUnsigned(bidx, vidx, val, offset = 0, len, nmax = 50000){
			let sample = {bidx: bidx, vidx: vidx};
			for(let k=0; k<nmax; k++){
				sample = getPrecValue(sample.bidx, sample.vidx, len);
				//console.log(`sample.value - offset: ${sample.value - offset}, val: ${val}`);
				if(Math.abs(sample.value - offset) > val){
					break;
				}
			}
			return sample;
		}
		
		function goBackUntilUpperNorm(bidx, vidx, val, offset = 0, len, nmax = 50000){
			let sample = {bidx: bidx, vidx: vidx};
			for(let k=0; k<nmax; k++){
				sample = getPrecValue(sample.bidx, sample.vidx, len);
				//console.log(`sample.value - offset: ${sample.value - offset}, val: ${val}`);
				if(sample.value - offset > val){
					break;
				}
			}
			return sample;
		}
		
		function goBackUntilUpperEqualNorm(bidx, vidx, val, offset = 0, len, nmax = 50000){
			let sample = {bidx: bidx, vidx: vidx};
			for(let k=0; k<nmax; k++){
				sample = getPrecValue(sample.bidx, sample.vidx, len);
				//console.log(`sample.value - offset: ${sample.value - offset}, val: ${val}`);
				if(sample.value - offset >= val){
					break;
				}
			}
			return sample;
		}
		
		function goBackUntilOutNorm(bidx, vidx, lower, upper, offset = 0, len, nmax = 50000){
			let sample = {bidx: bidx, vidx: vidx};
			for(let k=0; k<nmax; k++){
				sample = getPrecValue(sample.bidx, sample.vidx, len);
				//console.log(`sample.value - offset: ${sample.value - offset}, min: ${lower}, max: ${upper}`);
				if(sample.value - offset < lower || sample.value - offset > upper){
					break;
				}
			}
			return sample;
		}		

    </script>
	<script>
			// =====================================================
			// SISTEMA CURSORI DI MISURAZIONE - CODICE COMPLETO
			// =====================================================

			// Aggiorna display misurazioni
			function updateMeasurementDisplay() {
				const c1 = cursors.cursor1;
				const c2 = cursors.cursor2;
						
				const timeDiff = Math.abs(c2.time - c1.time);
				const batchDiff = Math.abs(c2.batchIndex - c1.batchIndex);
				const samplesPerBatch = Math.floor(SAMPLE_RATE / EXPECTED_BATCH_RATE);
				const sampleDiff = Math.abs(c2.sampleIndex - c1.sampleIndex) + batchDiff * samplesPerBatch;
				const valueDiff = c2.value - c1.value;
				
				if(cursors['cursor1'].time > 0 && cursors['cursor2'].time > 0){
					let rarea = relArea(cursors['cursor1'].batchIndex, cursors['cursor1'].sampleIndex, cursors['cursor2'].batchIndex, cursors['cursor2'].sampleIndex, Fstatico1, Fstatico2);
					//console.log('rarea: '+rarea);
					cursors['cursor1'].hv = rarea.hv;
					cursors['cursor2'].hv = rarea.hv;
					cursors['cursor1'].hl = rarea.hl;
					cursors['cursor2'].hl = rarea.hl;
					cursors['cursor1'].ht = rarea.ht;
					cursors['cursor2'].ht = rarea.ht;
					
					
					document.getElementById('timeDiff').textContent = formatTime(timeDiff);
					document.getElementById('batchDiff').textContent = `${batchDiff} batch`;
					document.getElementById('sampleDiff').textContent = `${sampleDiff.toLocaleString()} campioni`;
					document.getElementById('valueDiff').textContent = `${valueDiff > 0 ? '+' : ''}${valueDiff.toLocaleString()}`;
					document.getElementById('timeDiff').textContent = formatTime(timeDiff);
					document.getElementById('hv').textContent = `${rarea.hv}`;
					document.getElementById('hl').textContent = `${rarea.hl}`;
					document.getElementById('ht').textContent = `${rarea.ht}`;
					
					//console.log(`📏 Misurazioni: Δt=${formatTime(timeDiff)}, Δbatch=${batchDiff}, Δsample=${sampleDiff}, Δvalue=${valueDiff}`);
				}
			}

			// Formatta il tempo in modo leggibile
			function formatTime(microseconds) {
				if (microseconds >= 1000000) {
					return `${(microseconds / 1000000).toFixed(3)}s`;
				} else if (microseconds >= 1000) {
					return `${(microseconds / 1000).toFixed(3)}ms`;
				} else {
					return `${microseconds.toFixed(1)}μs`;
				}
			}

			// =====================================================
			// EVENT LISTENER PER CLICK SUL CANVAS
			// =====================================================
			
			// =====================================================
			// SISTEMA CURSORE TRASCINABILE
			// =====================================================
						
			// Sostituisci toggleDraggableCursor():
			function toggleDraggableCursor() {
				draggableCursorsActive = !draggableCursorsActive;
				const btn = document.getElementById('toggleDraggableCursor');
				const cursor1 = document.getElementById('draggableCursor1');
				const cursor2 = document.getElementById('draggableCursor2');
				const infoPanel1 = document.getElementById('cursorInfoPanel1');
				const infoPanel2 = document.getElementById('cursorInfoPanel2');
				const measurePanel = document.getElementById('measurementPanel');
				
				
				if (draggableCursorsActive) {
					if (recordBuffer.length === 0) {
						alert('⚠️ Carica prima un file con i dati per usare i cursori trascinabili!');
						draggableCursorsActive = false;
						return;
					}
					
					btn.textContent = 'Disattiva Cursori Trascinabili';
					btn.style.background = '#dc2626';
					cursor1.style.display = 'block';
					cursor2.style.display = 'block';
					infoPanel1.style.display = 'block';
					infoPanel2.style.display = 'block';
					measurePanel.style.display = 'block';
					
					const centerX = canvas.width / 2;
					updateDraggableCursorPosition('cursor1', centerX - 50);
					updateDraggableCursorPosition('cursor2', centerX + 50);
					
					console.log('🎯 Cursori trascinabili ATTIVATI');
				} else {
					btn.textContent = 'Attiva Cursori Trascinabili';
					btn.style.background = '#0ea5e9';
					cursor1.style.display = 'none';
					cursor2.style.display = 'none';
					infoPanel1.style.display = 'none';
					infoPanel2.style.display = 'none';
					measurePanel.style.display = 'none';
					
					cursors.cursor1 = { x: 0, time: 0, batchIndex: -1, sampleIndex: -1, value: 0, rf: 0 };
					cursors.cursor2 = { x: 0, time: 0, batchIndex: -1, sampleIndex: -1, value: 0, rf: 0 };
					
					if (!inputMode && recordBuffer.length > 0) {
						drawPlot();
					}
					
					console.log('❌ Cursori trascinabili DISATTIVATI');
				}
			}

			// Nuova funzione per aggiornare entrambi i pannelli:
			function updateDraggableCursorInfo() {
				['cursor1', 'cursor2'].forEach(cursorId => {
					const data = cursors[cursorId];
					const panelNum = cursorId.charAt(cursorId.length - 1); // Estrae '1' o '2'
					
					if (data.time > 0) {
						document.getElementById(`cursorTime${panelNum}`).textContent = formatTime(data.time);
						document.getElementById(`cursorBatch${panelNum}`).textContent = data.batchIndex.toString();
						document.getElementById(`cursorSampleIndex${panelNum}`).textContent = data.sampleIndex.toString();
						document.getElementById(`cursorValue${panelNum}`).textContent = `${data.value.toFixed(3)} : ${(data.value - Fstatico1).toFixed(3)}`;
						document.getElementById(`cursorPosition${panelNum}`).textContent = `${data.x.toFixed(1)}px`;
						document.getElementById(`relativeForce${panelNum}`).textContent = `${data.rf.toFixed(1)}%`;
						document.getElementById(`sdRatio${panelNum}`).textContent = `${data.sdRatio.toFixed(2)} sigma : ${data.sdRatio2.toFixed(2)} sigma`;
					} else {
						// Mostra valori vuoti se il cursore non è posizionato
						document.getElementById(`cursorTime${panelNum}`).textContent = '-';
						document.getElementById(`cursorBatch${panelNum}`).textContent = '-';
						document.getElementById(`cursorSampleIndex${panelNum}`).textContent = '-';
						document.getElementById(`cursorValue${panelNum}`).textContent = '-';
						document.getElementById(`cursorPosition${panelNum}`).textContent = '-';
						document.getElementById(`relativeForce${panelNum}`).textContent = '-';
						document.getElementById(`sdRatio${panelNum}`).textContent = '-';
					}
				});
				updateMeasurementDisplay();
			}
			
			function updateDraggableCursorPosition(cursorId, x) {
				const cursor = document.getElementById(`draggable${cursorId.charAt(0).toUpperCase() + cursorId.slice(1)}`);
				
				// Limita la posizione X ai bordi del canvas
				const minX = padding;
				const maxX = canvas.width - padding;
				x = Math.max(minX, Math.min(maxX, x));
				// CORREZIONE: Posiziona relativamente al canvas, non al documento
				cursor.style.left = x + 'px';
				cursor.style.bottom = '0px';
				// Calcola il tempo corrispondente
				const time = screenToTime(x);
				// Trova il valore più vicino sulla curva
				const cursorData = findValueAtTime(time);
				
				if (cursorData) {
					cursors[cursorId] = {
						x: x,
						time: cursorData.time,
						batchIndex: cursorData.batchIndex,
						sampleIndex: cursorData.sampleIndex,
						value: cursorData.value,
						rf: cursorData.rf, 
						relArea: 0,
						sdRatio: cursorData.sdRatio,
						sdRatio2: cursorData.sdRatio2
					};
					
					updateDraggableCursorInfo();
					// Ridisegna il plot per aggiornare l'evidenziazione
					if (!inputMode && recordBuffer.length > 0) {
						drawPlot();
					}
				}
			}

			// Sostituisci gli event listeners esistenti con:
			document.addEventListener('DOMContentLoaded', function() {
				['cursor1', 'cursor2'].forEach(cursorId => {
					const cursor = document.getElementById(`draggable${cursorId.charAt(0).toUpperCase() + cursorId.slice(1)}`);
					
					cursor.addEventListener('mousedown', function(e) {
						if (draggableCursorsActive) {
							isDragging = cursorId;
							e.preventDefault();
						}
					});
					
					cursor.addEventListener('touchstart', function(e) {
						if (draggableCursorsActive) {
							isDragging = cursorId;
							e.preventDefault();
						}
					});
				});
				
				canvas.addEventListener('mousedown', function(e) {
					if (draggableCursorsActive && !cursorMode) {
						const rect = canvas.getBoundingClientRect();
						const x = e.clientX - rect.left;
						// Determina quale cursore è più vicino
						const dist1 = Math.abs(x - cursors.cursor1.x);
						const dist2 = Math.abs(x - cursors.cursor2.x);
						isDragging = dist1 < dist2 ? 'cursor1' : 'cursor2';
						updateDraggableCursorPosition(isDragging, x);
						e.preventDefault();
					}
				});
				
				document.addEventListener('mousemove', function(e) {
					if (isDragging && draggableCursorsActive) {
						const canvasRect = canvas.getBoundingClientRect();
						const x = e.clientX - canvasRect.left;
						updateDraggableCursorPosition(isDragging, x);
					}
				});
				
				document.addEventListener('mouseup', function() {
					if (isDragging) {
						isDragging = null;
					}
				});
			});
			
			function findValueAtTime(targetTime) {
				if (recordBuffer.length === 0) return null;
				
				const BATCH_INTERVAL = 5000; // 5ms
				const firstBatchTime = parseInt(recordBuffer[0].t, 16);
				const batchLen = recordBuffer[0].v.length;
				const SAMPLE_INTERVAL = 0.005 / batchLen;  // 33μs
				//console.log('batchLen: '+batchLen);
				// Calcola offset totale dal primo batch
				const totalOffset = targetTime - firstBatchTime;
				//console.log('totalOffset: '+totalOffset);
				
				// Usa divisione e resto per trovare batch e sample
				const batchIndex = Math.floor(totalOffset / BATCH_INTERVAL);
				const timeInBatch = totalOffset % BATCH_INTERVAL;
				const sampleIndex = Math.floor(timeInBatch / SAMPLE_INTERVAL/1000000);
				//console.log('batchIndex: '+batchIndex);
				//console.log('timeInBatch: '+timeInBatch);
				//console.log('sampleIndex: '+sampleIndex);
				// Bounds check
				if (batchIndex < 0 || batchIndex >= recordBuffer.length) return null;
				if (sampleIndex >= recordBuffer[batchIndex].v.length) return null;
				
				const batch = recordBuffer[batchIndex];
				const value = calculateValue(batch.v[sampleIndex]);
				//console.log('value: '+value);
				const actualTime = parseInt(batch.t, 16) + (sampleIndex * SAMPLE_INTERVAL*1000000);
				//console.log('actualTime: '+actualTime);
				const Fstatico = (Fstatico1 + Fstatico2) / 2;
				console.log('findValueAtTime -> sd: '+globalSDMean);
				//console.log('sdratio: '+(value / sd));
				
				
				return {
					time: actualTime,
					batchIndex: batchIndex,
					sampleIndex: sampleIndex,
					value: value,
					distance: Math.abs(actualTime - targetTime),
					rf: (value - Fstatico) / Fstatico * 100,
					sdRatio: value / globalSDMean,
					sdRatio2: (value - Fstatico) / globalSDMean
				};	
			}
		</script>
</body>
</html>
